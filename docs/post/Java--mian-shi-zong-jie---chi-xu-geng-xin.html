<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark_colorblind" data-light-theme="light" lang="zh-CN">
<head>
    <meta name="keywords" content="5pyx55CG5ri4,丁公主,朱理游,000828,丁滢,博客,个人博客"/>
    <meta name="description" content="5pyx55CG5ri4,丁公主,朱理游,000828,丁滢,博客,个人博客"/>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href="//cdn.staticfile.net/Primer/21.0.7/primer.css" rel="stylesheet" />
    <link rel="icon" href="https://avatars.githubusercontent.com/u/50692323?v=4&size=64"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="<a name='bVG8o'></a>
## Java基础
<a name='GyAoN'></a>
### 集合
<a name='Huyq9'></a>
#### List
arraylist new初始容量为0 空数组 add第一个元素 扩容到10 后续每次扩容1.5倍左右 底层是数组复制来实现
<a name='D81x3'></a>
#### map
hashmap 1.7 数组+链表 1.8数组+链表+红黑树 <br />初始容量16 负载因子0.75(意味着容量到了百分之75的时候扩容) 当出现hash冲突 会使用拉链法解决冲突 如果同一个hash结果 key不同 进入链表 如果链表长度达到8 则转化为红黑树 转换前会判断数组长度是否大于64 如果小于64则会先对数组进行扩容 hashmap每次扩容是2倍 2的次幂 
<a name='zVXi1'></a>
### io
<a name='Lw7sM'></a>
### 多线程
<a name='bED23'></a>
#### 开启多线程的几种方式
 继承线程类或者实现接口
<a name='xxVR7'></a>
#### 线程的生命周期

1. 准备状态 如new thred 未调用start方法时
2. 就绪状态 调用了start方法 等待cpu资源
3. 运行状态
4. 阻塞状态 调用了sleep方法或者 wait方法
5. 线程结束
<a name='GEfNg'></a>
#### 线程池参数

1. 核心线程数
2. 最大线程数
3. 工作阻塞队列
4. 空闲线程存活时间
5. 存活时间单位
6. 拒绝策略
7. 线程工厂(不重要)
<a name='WpeCu'></a>
#### 线程池执行流程
一个任务进来  先开核心线程数是否超过设置的数量 如果没有 由核心线程执行任务如果核心线程数超过了设置的数量 则加入工作队列等待 如果 工作队列满了 并且没超过最大线程数 则开启临时新线程执行 临时线程存活时间由参数控制 回收 如果工作队列满了并且超过了最大线程数 则走拒绝策略
<a name='LADTg'></a>
#### ThredLocal
在每个线程中都有独立的一个thredlocalmap key为thredlocal value为存储的值 其中 key为弱引用 需要手动清理 否则可能会导致内存泄漏问题
<a name='iu8OP'></a>
#### sleep,wait
sleep是thred类的方法 作用是 休眠当前线程 无需唤醒<br />wait是object类方法 作用是是当前线程阻塞等待 在无参的方法中 需要等待别人唤醒
<a name='IViPI'></a>
### 锁机制
<a name='PRy6Z'></a>
#### volatile,sychronized和reentrantLock
volatile 关键字修饰变量 可以保证变量对每个线程的可见性 不加关键字 线程中读取的变量为从主内存复制的副本 加了关键字修饰 则直接读取主内存中的值<br />sychronized jvm提供的锁 为关键字 锁住的是对象头 分为 偏向锁 轻量级锁 自旋锁 重量级锁 是可重入锁 无法实现公平锁 无需手动释放锁<br />reentrantLock 是类 java提供的锁api 底层是aqs 锁的是int类型的state值 可重入锁 可实现公平锁和非公平锁 无参构造的是非公平锁 需要手动释放锁
<a name='NxzBu'></a>
#### AQS
aqs底层是一个双向队列和一个state信号量 java juc基本都依赖aqs框架 主要维护 信号量放行的逻辑
<a name='HynM0'></a>
#### CAS
比较并替换 可实现 乐观锁 
<a name='fjAPn'></a>
### 类加载机制
<a name='upWzo'></a>
#### 类加载过程

1. 加载:加载class文件 
2. 连接:1.验证 验证class文件合法性 2.准备 为变量设置内存并赋初始值 3.解析
3. 初始化
<a name='f2BXz'></a>
#### 双亲委派机制
加载类的时候 会先向父类加载器找有没有加载过这个类 如果没有 则继续往上  如果加载过了 则直接使用父类加载的结果 直到到达顶级 再向下尝试加载<br />好处  保护程序稳定 防止重复加载 防止java 核心 api被篡改 如自己定义string类
<a name='mcxZ6'></a>
#### 如何打破双亲委派
 自定义类加载器 重写加载方法
<a name='V9hvP'></a>
### JVM
<a name='hd8LH'></a>
#### 内存区域
程序计数器  线程私有 记录代码运行位置 控制流程<br />栈 分为虚拟机栈和本地方法栈 线程私有 方法开始压入栈帧 退出弹出栈帧 <br />堆 线程共享 存储对象 gc重要位置 分为 新生代和老生代 新生代分为ende区 s0 s1 <br />方法区/元空间 线程共享 存储 类信息 常量等信息<br />直接内存
<a name='IjIsL'></a>
#### GC
判断是否为垃圾的算法<br />1.引用计数法 有对象引用时+1 引用被清理时-1 引用为0 则为垃圾 弊端 无法解决循环引用问题<br />2.可达性分析法 从gc root开始往下找 找不到的对象均为垃圾  何为gcroot? 栈中引用的对象 方法区中静态属性和常量引用的对象 被同步锁持有的对象 

垃圾回收算法:<br />标记清除法 先标记需要清理的对象 再一次性回收 弊端 会造成大量的空间碎片 <br />标记复制法  将内存分为两大块 将需要回收的对象复制到空的内存块 再清理 弊端 内存消耗过大<br />标记整理法   将需要清理的内存标记 再将所有存活对象往一端移动 然后清理端边界的对象 

垃圾回收器:<br />串行垃圾回收器 原始版本 stw时间长 单线程垃圾回收 适用于小内存<br />并行垃圾回收器 串行的衍生版本 唯一不同的是垃圾回收时 多线程并行 减少stw时间<br />cms<br />g1
<a name='zmk00'></a>
#### 频繁出现GC的原因
cpu负载过高<br />大对象太多<br />老年代内存不足导致 频繁full gc 
<a name='ljQ8Y'></a>
## spring
<a name='I39Vj'></a>
### ioc
控制反转和依赖注入 原理是反射 
<a name='Eh6nE'></a>
### aop
切面 原理是反射和动态代理 生成动态代理对象 可对方法执行前和执行后进行拦截做处理
<a name='dR3WA'></a>
### bean的作用域
单例 默认 bean容器中所有bean都是唯一的<br />多例 每次获取都是一个新bean<br />requset 每个请求都是一个新bean<br />session 每个session都是一个新bean
<a name='JQvsP'></a>
### bean的生命周期

1. 实例化
2. 属性设置
3. 前置处理
4. 初始化处理
5. 后置处理
6. 使用中
7. 销毁前置操作
8. 死亡
<a name='Humjr'></a>
## springmvc
<a name='biEUj'></a>
### springmvc执行流程
请求过来 先到 调度servlet 由调度servlet找到处理器 handmapping 然后适配处理器 然后调用处理器找到对应的控制器 然后由控制器返回视图 渲染视图  
<a name='OwubK'></a>
## springboot
<a name='Mh9xT'></a>
## springcloud

1. Nacos 注册中心
2. Ribbon 负载均衡
3. OpenFeign 程序通信 http接口调用
4. Sentinel 降级 限流 服务保护 
5. Gateway 网关 鉴权
6. Seata 分布式事务 二阶段提交 AT模式和TCC模式
<a name='saFqN'></a>
## mybatis
<a name='LgOxQ'></a>
## redis
<a name='k21L7'></a>
## mq
<a name='hidFN'></a>
### 事务消费
<a name='uKi8v'></a>
### 顺序消费
<a name='sCjx0'></a>
## mysql
<a name='joSNR'></a>
### 常见锁
共享锁 读锁 排他锁 写锁 间隙锁 行锁 表锁等
<a name='fKJzk'></a>
### 数据引擎
myisam和innodb的区别<br />myisam 不支持事务 文件存储分为两个文件 索引文件和数据文件分开<br />innodb 支持事务 文件存储 一个文件 索引和数据都在一个文件中 mysql默认
<a name='xF1l9'></a>
### 索引
 普通索引 唯一索引 innodb中的主键索引(聚簇索引,特殊的唯一索引),联合索引,全文索引<br /> 底层B+Tree 多叉平衡树 叶子节点中有指针相连 节点有序 <br /> 索引覆盖 所需要查询的字段都建立了索引 不需要回表查询<br /> 最左匹配原则 如果联合索引 abc三个字段 那么查询的时候必须要有a这个字段的做为条件 才会走联合索引 因为存储索引的时候是按照从左往右按大小排序的
<a name='CwBPK'></a>
### 事务特征
 	A原子性 同时成功同时失败 <br /> 	C 一致性 事务要保持最终一致性  一致性需要 其他三个特征来保证<br /> 	I 隔离性 根据事务隔离级别控制 保证不同事务的隔离性<br /> 	D 持久性 事务最终需要持久化到数据库中  
<a name='JpxEB'></a>
### 事务隔离级别
 	读未提交  会产生脏读  级别最低 可以读到未提交的事务<br /> 	读已提交 不可重复读  两次查询可能会产生不一样的结果<br /> 	可重复读 mysql默认 会产生幻读 每次读取结果都一样<br /> 可串行化 级别最高 并发性能低 所有事务串行进行
<a name='V6Irz'></a>
### mvcc
在不可重复读和可重复读的事务隔离级别中有效 用来保证 事务的并发性<br />原理是通过版本链来控制 在每个表中有两个隐藏字段 一个是事务id一个是上个版本的地址快照<br />不可重复读中 每次查询都会生成新的 readView 所以会产生两次查询不一样<br />可重复读中 会使用上次的readView 所以每次读取结果都一样 
<a name='xnPLQ'></a>
### mysql 锁等待超时
<a name='cSEgX'></a>
### limit 大数据量优化
<a name='MJmJe'></a>
## liunx

last:20240625。">
<meta property="og:title" content="Java-面试总结-持续更新">
<meta property="og:description" content="<a name='bVG8o'></a>
## Java基础
<a name='GyAoN'></a>
### 集合
<a name='Huyq9'></a>
#### List
arraylist new初始容量为0 空数组 add第一个元素 扩容到10 后续每次扩容1.5倍左右 底层是数组复制来实现
<a name='D81x3'></a>
#### map
hashmap 1.7 数组+链表 1.8数组+链表+红黑树 <br />初始容量16 负载因子0.75(意味着容量到了百分之75的时候扩容) 当出现hash冲突 会使用拉链法解决冲突 如果同一个hash结果 key不同 进入链表 如果链表长度达到8 则转化为红黑树 转换前会判断数组长度是否大于64 如果小于64则会先对数组进行扩容 hashmap每次扩容是2倍 2的次幂 
<a name='zVXi1'></a>
### io
<a name='Lw7sM'></a>
### 多线程
<a name='bED23'></a>
#### 开启多线程的几种方式
 继承线程类或者实现接口
<a name='xxVR7'></a>
#### 线程的生命周期

1. 准备状态 如new thred 未调用start方法时
2. 就绪状态 调用了start方法 等待cpu资源
3. 运行状态
4. 阻塞状态 调用了sleep方法或者 wait方法
5. 线程结束
<a name='GEfNg'></a>
#### 线程池参数

1. 核心线程数
2. 最大线程数
3. 工作阻塞队列
4. 空闲线程存活时间
5. 存活时间单位
6. 拒绝策略
7. 线程工厂(不重要)
<a name='WpeCu'></a>
#### 线程池执行流程
一个任务进来  先开核心线程数是否超过设置的数量 如果没有 由核心线程执行任务如果核心线程数超过了设置的数量 则加入工作队列等待 如果 工作队列满了 并且没超过最大线程数 则开启临时新线程执行 临时线程存活时间由参数控制 回收 如果工作队列满了并且超过了最大线程数 则走拒绝策略
<a name='LADTg'></a>
#### ThredLocal
在每个线程中都有独立的一个thredlocalmap key为thredlocal value为存储的值 其中 key为弱引用 需要手动清理 否则可能会导致内存泄漏问题
<a name='iu8OP'></a>
#### sleep,wait
sleep是thred类的方法 作用是 休眠当前线程 无需唤醒<br />wait是object类方法 作用是是当前线程阻塞等待 在无参的方法中 需要等待别人唤醒
<a name='IViPI'></a>
### 锁机制
<a name='PRy6Z'></a>
#### volatile,sychronized和reentrantLock
volatile 关键字修饰变量 可以保证变量对每个线程的可见性 不加关键字 线程中读取的变量为从主内存复制的副本 加了关键字修饰 则直接读取主内存中的值<br />sychronized jvm提供的锁 为关键字 锁住的是对象头 分为 偏向锁 轻量级锁 自旋锁 重量级锁 是可重入锁 无法实现公平锁 无需手动释放锁<br />reentrantLock 是类 java提供的锁api 底层是aqs 锁的是int类型的state值 可重入锁 可实现公平锁和非公平锁 无参构造的是非公平锁 需要手动释放锁
<a name='NxzBu'></a>
#### AQS
aqs底层是一个双向队列和一个state信号量 java juc基本都依赖aqs框架 主要维护 信号量放行的逻辑
<a name='HynM0'></a>
#### CAS
比较并替换 可实现 乐观锁 
<a name='fjAPn'></a>
### 类加载机制
<a name='upWzo'></a>
#### 类加载过程

1. 加载:加载class文件 
2. 连接:1.验证 验证class文件合法性 2.准备 为变量设置内存并赋初始值 3.解析
3. 初始化
<a name='f2BXz'></a>
#### 双亲委派机制
加载类的时候 会先向父类加载器找有没有加载过这个类 如果没有 则继续往上  如果加载过了 则直接使用父类加载的结果 直到到达顶级 再向下尝试加载<br />好处  保护程序稳定 防止重复加载 防止java 核心 api被篡改 如自己定义string类
<a name='mcxZ6'></a>
#### 如何打破双亲委派
 自定义类加载器 重写加载方法
<a name='V9hvP'></a>
### JVM
<a name='hd8LH'></a>
#### 内存区域
程序计数器  线程私有 记录代码运行位置 控制流程<br />栈 分为虚拟机栈和本地方法栈 线程私有 方法开始压入栈帧 退出弹出栈帧 <br />堆 线程共享 存储对象 gc重要位置 分为 新生代和老生代 新生代分为ende区 s0 s1 <br />方法区/元空间 线程共享 存储 类信息 常量等信息<br />直接内存
<a name='IjIsL'></a>
#### GC
判断是否为垃圾的算法<br />1.引用计数法 有对象引用时+1 引用被清理时-1 引用为0 则为垃圾 弊端 无法解决循环引用问题<br />2.可达性分析法 从gc root开始往下找 找不到的对象均为垃圾  何为gcroot? 栈中引用的对象 方法区中静态属性和常量引用的对象 被同步锁持有的对象 

垃圾回收算法:<br />标记清除法 先标记需要清理的对象 再一次性回收 弊端 会造成大量的空间碎片 <br />标记复制法  将内存分为两大块 将需要回收的对象复制到空的内存块 再清理 弊端 内存消耗过大<br />标记整理法   将需要清理的内存标记 再将所有存活对象往一端移动 然后清理端边界的对象 

垃圾回收器:<br />串行垃圾回收器 原始版本 stw时间长 单线程垃圾回收 适用于小内存<br />并行垃圾回收器 串行的衍生版本 唯一不同的是垃圾回收时 多线程并行 减少stw时间<br />cms<br />g1
<a name='zmk00'></a>
#### 频繁出现GC的原因
cpu负载过高<br />大对象太多<br />老年代内存不足导致 频繁full gc 
<a name='ljQ8Y'></a>
## spring
<a name='I39Vj'></a>
### ioc
控制反转和依赖注入 原理是反射 
<a name='Eh6nE'></a>
### aop
切面 原理是反射和动态代理 生成动态代理对象 可对方法执行前和执行后进行拦截做处理
<a name='dR3WA'></a>
### bean的作用域
单例 默认 bean容器中所有bean都是唯一的<br />多例 每次获取都是一个新bean<br />requset 每个请求都是一个新bean<br />session 每个session都是一个新bean
<a name='JQvsP'></a>
### bean的生命周期

1. 实例化
2. 属性设置
3. 前置处理
4. 初始化处理
5. 后置处理
6. 使用中
7. 销毁前置操作
8. 死亡
<a name='Humjr'></a>
## springmvc
<a name='biEUj'></a>
### springmvc执行流程
请求过来 先到 调度servlet 由调度servlet找到处理器 handmapping 然后适配处理器 然后调用处理器找到对应的控制器 然后由控制器返回视图 渲染视图  
<a name='OwubK'></a>
## springboot
<a name='Mh9xT'></a>
## springcloud

1. Nacos 注册中心
2. Ribbon 负载均衡
3. OpenFeign 程序通信 http接口调用
4. Sentinel 降级 限流 服务保护 
5. Gateway 网关 鉴权
6. Seata 分布式事务 二阶段提交 AT模式和TCC模式
<a name='saFqN'></a>
## mybatis
<a name='LgOxQ'></a>
## redis
<a name='k21L7'></a>
## mq
<a name='hidFN'></a>
### 事务消费
<a name='uKi8v'></a>
### 顺序消费
<a name='sCjx0'></a>
## mysql
<a name='joSNR'></a>
### 常见锁
共享锁 读锁 排他锁 写锁 间隙锁 行锁 表锁等
<a name='fKJzk'></a>
### 数据引擎
myisam和innodb的区别<br />myisam 不支持事务 文件存储分为两个文件 索引文件和数据文件分开<br />innodb 支持事务 文件存储 一个文件 索引和数据都在一个文件中 mysql默认
<a name='xF1l9'></a>
### 索引
 普通索引 唯一索引 innodb中的主键索引(聚簇索引,特殊的唯一索引),联合索引,全文索引<br /> 底层B+Tree 多叉平衡树 叶子节点中有指针相连 节点有序 <br /> 索引覆盖 所需要查询的字段都建立了索引 不需要回表查询<br /> 最左匹配原则 如果联合索引 abc三个字段 那么查询的时候必须要有a这个字段的做为条件 才会走联合索引 因为存储索引的时候是按照从左往右按大小排序的
<a name='CwBPK'></a>
### 事务特征
 	A原子性 同时成功同时失败 <br /> 	C 一致性 事务要保持最终一致性  一致性需要 其他三个特征来保证<br /> 	I 隔离性 根据事务隔离级别控制 保证不同事务的隔离性<br /> 	D 持久性 事务最终需要持久化到数据库中  
<a name='JpxEB'></a>
### 事务隔离级别
 	读未提交  会产生脏读  级别最低 可以读到未提交的事务<br /> 	读已提交 不可重复读  两次查询可能会产生不一样的结果<br /> 	可重复读 mysql默认 会产生幻读 每次读取结果都一样<br /> 可串行化 级别最高 并发性能低 所有事务串行进行
<a name='V6Irz'></a>
### mvcc
在不可重复读和可重复读的事务隔离级别中有效 用来保证 事务的并发性<br />原理是通过版本链来控制 在每个表中有两个隐藏字段 一个是事务id一个是上个版本的地址快照<br />不可重复读中 每次查询都会生成新的 readView 所以会产生两次查询不一样<br />可重复读中 会使用上次的readView 所以每次读取结果都一样 
<a name='xnPLQ'></a>
### mysql 锁等待超时
<a name='cSEgX'></a>
### limit 大数据量优化
<a name='MJmJe'></a>
## liunx

last:20240625。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.000828.top//post/Java--mian-shi-zong-jie---chi-xu-geng-xin.html">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg">
<title>Java-面试总结-持续更新</title>


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">Java-面试总结-持续更新</h1>
<div class="title-right">
    <a href="https://blog.000828.top/" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p><a name="user-content-bvg8o"></a></p>
<h2>Java基础</h2>
<p><a name="user-content-gyaon"></a></p>
<h3>集合</h3>
<p><a name="user-content-huyq9"></a></p>
<h4>List</h4>
<p>arraylist new初始容量为0 空数组 add第一个元素 扩容到10 后续每次扩容1.5倍左右 底层是数组复制来实现<br>
<a name="user-content-d81x3"></a></p>
<h4>map</h4>
<p>hashmap 1.7 数组+链表 1.8数组+链表+红黑树 <br>初始容量16 负载因子0.75(意味着容量到了百分之75的时候扩容) 当出现hash冲突 会使用拉链法解决冲突 如果同一个hash结果 key不同 进入链表 如果链表长度达到8 则转化为红黑树 转换前会判断数组长度是否大于64 如果小于64则会先对数组进行扩容 hashmap每次扩容是2倍 2的次幂<br>
<a name="user-content-zvxi1"></a></p>
<h3>io</h3>
<p><a name="user-content-lw7sm"></a></p>
<h3>多线程</h3>
<p><a name="user-content-bed23"></a></p>
<h4>开启多线程的几种方式</h4>
<p>继承线程类或者实现接口<br>
<a name="user-content-xxvr7"></a></p>
<h4>线程的生命周期</h4>
<ol>
<li>准备状态 如new thred 未调用start方法时</li>
<li>就绪状态 调用了start方法 等待cpu资源</li>
<li>运行状态</li>
<li>阻塞状态 调用了sleep方法或者 wait方法</li>
<li>线程结束<br>
<a name="user-content-gefng"></a></li>
</ol>
<h4>线程池参数</h4>
<ol>
<li>核心线程数</li>
<li>最大线程数</li>
<li>工作阻塞队列</li>
<li>空闲线程存活时间</li>
<li>存活时间单位</li>
<li>拒绝策略</li>
<li>线程工厂(不重要)<br>
<a name="user-content-wpecu"></a></li>
</ol>
<h4>线程池执行流程</h4>
<p>一个任务进来  先开核心线程数是否超过设置的数量 如果没有 由核心线程执行任务如果核心线程数超过了设置的数量 则加入工作队列等待 如果 工作队列满了 并且没超过最大线程数 则开启临时新线程执行 临时线程存活时间由参数控制 回收 如果工作队列满了并且超过了最大线程数 则走拒绝策略<br>
<a name="user-content-ladtg"></a></p>
<h4>ThredLocal</h4>
<p>在每个线程中都有独立的一个thredlocalmap key为thredlocal value为存储的值 其中 key为弱引用 需要手动清理 否则可能会导致内存泄漏问题<br>
<a name="user-content-iu8op"></a></p>
<h4>sleep,wait</h4>
<p>sleep是thred类的方法 作用是 休眠当前线程 无需唤醒<br>wait是object类方法 作用是是当前线程阻塞等待 在无参的方法中 需要等待别人唤醒<br>
<a name="user-content-ivipi"></a></p>
<h3>锁机制</h3>
<p><a name="user-content-pry6z"></a></p>
<h4>volatile,sychronized和reentrantLock</h4>
<p>volatile 关键字修饰变量 可以保证变量对每个线程的可见性 不加关键字 线程中读取的变量为从主内存复制的副本 加了关键字修饰 则直接读取主内存中的值<br>sychronized jvm提供的锁 为关键字 锁住的是对象头 分为 偏向锁 轻量级锁 自旋锁 重量级锁 是可重入锁 无法实现公平锁 无需手动释放锁<br>reentrantLock 是类 java提供的锁api 底层是aqs 锁的是int类型的state值 可重入锁 可实现公平锁和非公平锁 无参构造的是非公平锁 需要手动释放锁<br>
<a name="user-content-nxzbu"></a></p>
<h4>AQS</h4>
<p>aqs底层是一个双向队列和一个state信号量 java juc基本都依赖aqs框架 主要维护 信号量放行的逻辑<br>
<a name="user-content-hynm0"></a></p>
<h4>CAS</h4>
<p>比较并替换 可实现 乐观锁<br>
<a name="user-content-fjapn"></a></p>
<h3>类加载机制</h3>
<p><a name="user-content-upwzo"></a></p>
<h4>类加载过程</h4>
<ol>
<li>加载:加载class文件</li>
<li>连接:1.验证 验证class文件合法性 2.准备 为变量设置内存并赋初始值 3.解析</li>
<li>初始化<br>
<a name="user-content-f2bxz"></a></li>
</ol>
<h4>双亲委派机制</h4>
<p>加载类的时候 会先向父类加载器找有没有加载过这个类 如果没有 则继续往上  如果加载过了 则直接使用父类加载的结果 直到到达顶级 再向下尝试加载<br>好处  保护程序稳定 防止重复加载 防止java 核心 api被篡改 如自己定义string类<br>
<a name="user-content-mcxz6"></a></p>
<h4>如何打破双亲委派</h4>
<p>自定义类加载器 重写加载方法<br>
<a name="user-content-v9hvp"></a></p>
<h3>JVM</h3>
<p><a name="user-content-hd8lh"></a></p>
<h4>内存区域</h4>
<p>程序计数器  线程私有 记录代码运行位置 控制流程<br>栈 分为虚拟机栈和本地方法栈 线程私有 方法开始压入栈帧 退出弹出栈帧 <br>堆 线程共享 存储对象 gc重要位置 分为 新生代和老生代 新生代分为ende区 s0 s1 <br>方法区/元空间 线程共享 存储 类信息 常量等信息<br>直接内存<br>
<a name="user-content-ijisl"></a></p>
<h4>GC</h4>
<p>判断是否为垃圾的算法<br>1.引用计数法 有对象引用时+1 引用被清理时-1 引用为0 则为垃圾 弊端 无法解决循环引用问题<br>2.可达性分析法 从gc root开始往下找 找不到的对象均为垃圾  何为gcroot? 栈中引用的对象 方法区中静态属性和常量引用的对象 被同步锁持有的对象</p>
<p>垃圾回收算法:<br>标记清除法 先标记需要清理的对象 再一次性回收 弊端 会造成大量的空间碎片 <br>标记复制法  将内存分为两大块 将需要回收的对象复制到空的内存块 再清理 弊端 内存消耗过大<br>标记整理法   将需要清理的内存标记 再将所有存活对象往一端移动 然后清理端边界的对象</p>
<p>垃圾回收器:<br>串行垃圾回收器 原始版本 stw时间长 单线程垃圾回收 适用于小内存<br>并行垃圾回收器 串行的衍生版本 唯一不同的是垃圾回收时 多线程并行 减少stw时间<br>cms<br>g1<br>
<a name="user-content-zmk00"></a></p>
<h4>频繁出现GC的原因</h4>
<p>cpu负载过高<br>大对象太多<br>老年代内存不足导致 频繁full gc<br>
<a name="user-content-ljq8y"></a></p>
<h2>spring</h2>
<p><a name="user-content-i39vj"></a></p>
<h3>ioc</h3>
<p>控制反转和依赖注入 原理是反射<br>
<a name="user-content-eh6ne"></a></p>
<h3>aop</h3>
<p>切面 原理是反射和动态代理 生成动态代理对象 可对方法执行前和执行后进行拦截做处理<br>
<a name="user-content-dr3wa"></a></p>
<h3>bean的作用域</h3>
<p>单例 默认 bean容器中所有bean都是唯一的<br>多例 每次获取都是一个新bean<br>requset 每个请求都是一个新bean<br>session 每个session都是一个新bean<br>
<a name="user-content-jqvsp"></a></p>
<h3>bean的生命周期</h3>
<ol>
<li>实例化</li>
<li>属性设置</li>
<li>前置处理</li>
<li>初始化处理</li>
<li>后置处理</li>
<li>使用中</li>
<li>销毁前置操作</li>
<li>死亡<br>
<a name="user-content-humjr"></a></li>
</ol>
<h2>springmvc</h2>
<p><a name="user-content-bieuj"></a></p>
<h3>springmvc执行流程</h3>
<p>请求过来 先到 调度servlet 由调度servlet找到处理器 handmapping 然后适配处理器 然后调用处理器找到对应的控制器 然后由控制器返回视图 渲染视图<br>
<a name="user-content-owubk"></a></p>
<h2>springboot</h2>
<p><a name="user-content-mh9xt"></a></p>
<h2>springcloud</h2>
<ol>
<li>Nacos 注册中心</li>
<li>Ribbon 负载均衡</li>
<li>OpenFeign 程序通信 http接口调用</li>
<li>Sentinel 降级 限流 服务保护</li>
<li>Gateway 网关 鉴权</li>
<li>Seata 分布式事务 二阶段提交 AT模式和TCC模式<br>
<a name="user-content-safqn"></a></li>
</ol>
<h2>mybatis</h2>
<p><a name="user-content-lgoxq"></a></p>
<h2>redis</h2>
<p><a name="user-content-k21l7"></a></p>
<h2>mq</h2>
<p><a name="user-content-hidfn"></a></p>
<h3>事务消费</h3>
<p><a name="user-content-uki8v"></a></p>
<h3>顺序消费</h3>
<p><a name="user-content-scjx0"></a></p>
<h2>mysql</h2>
<p><a name="user-content-josnr"></a></p>
<h3>常见锁</h3>
<p>共享锁 读锁 排他锁 写锁 间隙锁 行锁 表锁等<br>
<a name="user-content-fkjzk"></a></p>
<h3>数据引擎</h3>
<p>myisam和innodb的区别<br>myisam 不支持事务 文件存储分为两个文件 索引文件和数据文件分开<br>innodb 支持事务 文件存储 一个文件 索引和数据都在一个文件中 mysql默认<br>
<a name="user-content-xf1l9"></a></p>
<h3>索引</h3>
<p>普通索引 唯一索引 innodb中的主键索引(聚簇索引,特殊的唯一索引),联合索引,全文索引<br> 底层B+Tree 多叉平衡树 叶子节点中有指针相连 节点有序 <br> 索引覆盖 所需要查询的字段都建立了索引 不需要回表查询<br> 最左匹配原则 如果联合索引 abc三个字段 那么查询的时候必须要有a这个字段的做为条件 才会走联合索引 因为存储索引的时候是按照从左往右按大小排序的<br>
<a name="user-content-cwbpk"></a></p>
<h3>事务特征</h3>
<pre class="notranslate"><code class="notranslate">A原子性 同时成功同时失败 &lt;br /&gt; 	C 一致性 事务要保持最终一致性  一致性需要 其他三个特征来保证&lt;br /&gt; 	I 隔离性 根据事务隔离级别控制 保证不同事务的隔离性&lt;br /&gt; 	D 持久性 事务最终需要持久化到数据库中  
</code></pre>
<p><a name="user-content-jpxeb"></a></p>
<h3>事务隔离级别</h3>
<pre class="notranslate"><code class="notranslate">读未提交  会产生脏读  级别最低 可以读到未提交的事务&lt;br /&gt; 	读已提交 不可重复读  两次查询可能会产生不一样的结果&lt;br /&gt; 	可重复读 mysql默认 会产生幻读 每次读取结果都一样&lt;br /&gt; 可串行化 级别最高 并发性能低 所有事务串行进行
</code></pre>
<p><a name="user-content-v6irz"></a></p>
<h3>mvcc</h3>
<p>在不可重复读和可重复读的事务隔离级别中有效 用来保证 事务的并发性<br>原理是通过版本链来控制 在每个表中有两个隐藏字段 一个是事务id一个是上个版本的地址快照<br>不可重复读中 每次查询都会生成新的 readView 所以会产生两次查询不一样<br>可重复读中 会使用上次的readView 所以每次读取结果都一样<br>
<a name="user-content-xnplq"></a></p>
<h3>mysql 锁等待超时</h3>
<p><a name="user-content-csegx"></a></p>
<h3>limit 大数据量优化</h3>
<p><a name="user-content-mjmje"></a></p>
<h2>liunx</h2>
<p>last:20240625</p></div>
<div style="font-size:small;margin-top:8px;float:right;">
   By 5pyx55CG5ri4 -   - {'singlePage': ['link', 'about'], 'startSite': '01/03/2023', 'filingNum': '', 'onePageListNum': 15, 'commentLabelColor': '#006b75', 'yearColorList': ['#bc4c00', '#0969da', '#1f883d', '#A333D0'], 'i18n': 'CN', 'themeMode': 'manual', 'dayTheme': 'light', 'nightTheme': 'dark_colorblind', 'urlMode': 'pinyin', 'script': '', 'style': '', 'indexScript': '', 'indexStyle': '', 'bottomText': '5pyx55CG5ri4', 'showPostSource': 0, 'iconList': {'music': 'M12.7 0.9L7.3 0.9C6 0.9 4.9 2 4.9 3.3L4.9 10.1C4.5 9.9 4.1 9.8 3.6 9.8C2.1 9.8 0.9 11 0.9 12.4C0.9 13.9 2.1 15.1 3.6 15.1C5 15.1 6.2 13.9 6.2 12.4L6.2 3.3C6.2 2.7 6.7 2.2 7.3 2.2L12.7 2.2C13.3 2.2 13.8 2.7 13.8 3.3L13.8 7.5C13.4 7.3 12.9 7.1 12.4 7.1C11 7.1 9.8 8.3 9.8 9.8C9.8 11.2 11 12.4 12.4 12.4C13.9 12.4 15.1 11.2 15.1 9.8L15.1 3.3C15.1 2 14 0.9 12.7 0.9ZM3.6 13.8C2.8 13.8 2.2 13.2 2.2 12.4C2.2 11.7 2.8 11.1 3.6 11.1C4.3 11.1 4.9 11.7 4.9 12.4C4.9 13.2 4.3 13.8 3.6 13.8ZM12.4 11.1C11.7 11.1 11.1 10.5 11.1 9.8C11.1 9 11.7 8.4 12.4 8.4C13.2 8.4 13.8 9 13.8 9.8C13.8 10.5 13.2 11.1 12.4 11.1ZM12.4 11.1'}, 'UTC': 8, 'rssSplit': 'sentence', 'exlink': {'music': 'https://music.meekdai.com'}, 'title': '5pyx55CG5ri4', 'subTitle': '永远相信美好的事情即将发生', 'avatarUrl': 'https://avatars.githubusercontent.com/u/50692323?v=4&size=64', 'homeUrl': 'https://blog.000828.top/', 'email': 'zhu990611@gmail.com', 'ogImage': 'https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg', 'GMEEK_VERSION': 'last', 'postListJson': {'P15': {'htmlDir': 'docs/post/25 years old.html', 'labels': ['恋爱日记'], 'postTitle': '25 years old', 'postUrl': 'post/25%20years%20old.html', 'postSourceUrl': 'https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/issues/15', 'commentNum': 1, 'wordCount': 788, 'description': "**25岁了,收到了这辈子目前为止最生猛的礼物**\r\n\r\n**1.  主机+显示器+键鼠全家桶全配齐了 我应该是世界上最幸福的男人吧 是男人都得羡慕我 😀**\r\n\r\n`Gmeek-html<img src='https://img.000828.top/file/73c8722d6d25b3125492a.jpg'>`\r\n\r\n**2. 荷花(真花)+荷花(烟) 😀**\r\n\r\n`Gmeek-html<img src='https://img.000828.top/file/778375e35b72ff81f7df7.jpg'>`\r\n\r\n**3. GG Bond 蛋糕 我 想一直做你的英雄 不止是童话里 😍**\r\n\r\n`Gmeek-html<img src='https://img.000828.top/file/ee9408db9cb94520edd40.jpg'>`\r\n\r\n**4. 去年的今天,也是你陪我一起 仪式感拉满**\r\n\r\n`Gmeek-html<img src='https://img.000828.top/file/215eb0b78642469d7d35f.jpg'>`\r\n\r\n> [!NOTE]\r\n> **感谢我的宝贝**\r\n\r\n   `Gmeek-html<div><span>找到你是最伟大的成功</span><audio src='https://m10.music.126.net/20240717185349/316c4179dda689d4f3c883fa914215f2/ymusic/faf2/9ebc/34cb/249fa10bd68667096064acc1ebcac4f1.mp3' controls></audio><div>`\r\n\r\n\r\n\r\n\r\n<!-- ##{'timestamp':1721059200}## -->。", 'top': 0, 'createdAt': 1721059200, 'style': '<style>.markdown-alert{padding:0.5rem 1rem;margin-bottom:1rem;border-left:.25em solid var(--borderColor-default,var(--color-border-default));}.markdown-alert .markdown-alert-title {display:flex;font-weight:var(--base-text-weight-medium,500);align-items:center;line-height:1;}.markdown-alert>:first-child {margin-top:0;}.markdown-alert>:last-child {margin-bottom:0;}</style><style>.markdown-alert.markdown-alert-note {border-left-color:var(--borderColor-accent-emphasis, var(--color-accent-emphasis));background-color:var(--color-accent-subtle);}.markdown-alert.markdown-alert-note .markdown-alert-title {color: var(--fgColor-accent,var(--color-accent-fg));}</style>', 'script': '', 'ogImage': 'https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg', 'createdDate': '2024-07-16', 'dateLabelColor': '#bc4c00'}, 'P14': {'htmlDir': 'docs/post/18 months.html', 'labels': ['恋爱日记'], 'postTitle': '18 months', 'postUrl': 'post/18%20months.html', 'postSourceUrl': 'https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/issues/14', 'commentNum': 0, 'wordCount': 360, 'description': "在一起的第18个月\r\n最近我们的感情出了点问题 频繁吵架\r\n她觉得我变了 感受不到安全感了 **深刻反思** \r\n也许是到了平淡期 但是我想找到平衡点 \r\n后面也聊了很久 说了很多内心的想法  我想跟她好好的并且能一直走下去\r\n\r\n### 给她买的荔枝花束 带她去吃了最近想吃的火锅 😀\r\n![0af196511eb70adc54dc1](https://img.000828.top/file/0af196511eb70adc54dc1.jpg)\r\n![b86986b17106adda1db42](https://img.000828.top/file/b86986b17106adda1db42.jpg)\r\n\r\n最后 18个月快乐~\r\n\r\n<!-- ##{'timestamp':1719983839}## -->。", 'top': 0, 'createdAt': 1719983839, 'style': '', 'script': '', 'ogImage': 'https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg', 'createdDate': '2024-07-03', 'dateLabelColor': '#bc4c00'}, 'P13': {'htmlDir': 'docs/post/ji-yu-edge-tts-de-wen-zi-zhuan-yu-yin-gong-ju--python.html', 'labels': ['技术博客'], 'postTitle': '基于edge-tts的文字转语音工具-python', 'postUrl': 'post/ji-yu-edge-tts-de-wen-zi-zhuan-yu-yin-gong-ju--python.html', 'postSourceUrl': 'https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/issues/13', 'commentNum': 1, 'wordCount': 5122, 'description': "最近想整点副业 想做小说推文 找了些文字转语音工具 发现大部分都有字数限制 于是自己开发了一个 基于开源的edge-tts 带图形化界面(虽然有点丑)\r\n\r\n仅支持windows\r\n\r\n支持文字转语音 调整音色 语速 语调\r\n\r\n\r\n[github地址](https://github.com/5pyx55CG5ri4/TTS)\r\n\r\n[releases](https://github.com/5pyx55CG5ri4/TTS/releases)\r\n```python\r\nimport asyncio\r\nimport threading\r\nimport tkinter as tk\r\nfrom datetime import datetime\r\nfrom tkinter import messagebox, scrolledtext, ttk\r\n\r\nimport edge_tts\r\nimport pygame\r\n\r\n\r\nclass TTSApp:\r\n    def __init__(self, root):\r\n        self.root = root\r\n        self.root.title('小说推文工具')\r\n        self.root.geometry('600x700')\r\n\r\n        self.notebook = ttk.Notebook(self.root)\r\n        self.notebook.pack(fill=tk.BOTH, expand=True)\r\n\r\n        self.tts_page = TTSPage(self.notebook)\r\n\r\n        self.notebook.add(self.tts_page, text='TTS(文字转语音)')\r\n\r\n\r\nclass TTSPage(tk.Frame):\r\n    def __init__(self, parent):\r\n        super().__init__(parent)\r\n\r\n        self.create_widgets()\r\n\r\n    def create_widgets(self):\r\n        title_label = tk.Label(self, text='TTS(文字转语音)', font=('Helvetica', 24, 'bold'))\r\n        title_label.pack(pady=10)\r\n\r\n        text_frame = tk.Frame(self)\r\n        text_frame.pack(padx=10, pady=10)\r\n\r\n        self.text_area = scrolledtext.ScrolledText(text_frame, wrap=tk.WORD, width=60, height=15,\r\n                                                   font=('Helvetica', 12))\r\n        self.text_area.pack(padx=10, pady=10)\r\n\r\n        control_frame = tk.Frame(self)\r\n        control_frame.pack(padx=10, pady=5)\r\n\r\n        rate_label = tk.Label(control_frame, text='语速:', font=('Helvetica', 12))\r\n        rate_label.grid(row=0, column=0, padx=5)\r\n\r\n        self.rate_slider = tk.Scale(control_frame, from_=-100, to=100, orient=tk.HORIZONTAL, length=200)\r\n        self.rate_slider.grid(row=0, column=1, padx=5)\r\n\r\n        pitch_label = tk.Label(control_frame, text='语调:', font=('Helvetica', 12))\r\n        pitch_label.grid(row=1, column=0, padx=5)\r\n\r\n        self.pitch_slider = tk.Scale(control_frame, from_=-50, to=50, orient=tk.HORIZONTAL, length=200)\r\n        self.pitch_slider.grid(row=1, column=1, padx=5)\r\n\r\n        voice_label = tk.Label(control_frame, text='音色:', font=('Helvetica', 12))\r\n        voice_label.grid(row=2, column=0, padx=5)\r\n\r\n        self.voice_combobox = tk.StringVar()\r\n        self.voice_combobox.set('晓晓')\r\n        self.voice_dropdown = tk.OptionMenu(control_frame, self.voice_combobox, '晓晓', '晓伊', '云健', '云希', '云扬',\r\n                                            '云夏', '陕西方言')\r\n        self.voice_dropdown.config(font=('Helvetica', 12))\r\n        self.voice_dropdown.grid(row=2, column=1, padx=5)\r\n\r\n        generate_button = tk.Button(self, text='生成语音', command=self.start_generate_speech,\r\n                                    font=('Helvetica', 14, 'bold'),\r\n                                    bg='#4CAF50', fg='white')\r\n        generate_button.pack(padx=10, pady=10)\r\n\r\n        self.progress_bar = ttk.Progressbar(self, mode='indeterminate')\r\n        self.progress_bar.pack(padx=10, pady=10, fill=tk.X)\r\n\r\n        self.play_button = tk.Button(self, text='播放语音', command=self.play_audio, font=('Helvetica', 14, 'bold'),\r\n                                     bg='#4CAF50', fg='white', state=tk.DISABLED)\r\n        self.play_button.pack(padx=10, pady=10)\r\n\r\n    async def text_to_speech(self, text, rate, pitch, voice):\r\n        filename = datetime.now().strftime('%Y%m%d_%H%M%S_%f') + '.mp3'\r\n        communicate = edge_tts.Communicate(text, voice, rate=rate, pitch=pitch)\r\n        await communicate.save(filename)\r\n        self.audio_filename = filename\r\n\r\n    def generate_speech(self):\r\n        text = self.text_area.get('1.0', tk.END).strip()\r\n        if not text:\r\n            messagebox.showwarning('警告', '请输入文本内容')\r\n            return\r\n\r\n        rate = f'{self.rate_slider.get():+d}%'\r\n        pitch_value = self.pitch_slider.get()\r\n        pitch = f'{pitch_value:+d}Hz' if pitch_value != 0 else '+0Hz'  # 如果pitch为0，则设置为字符串'0Hz'\r\n        voice = self.voice_combobox.get()\r\n        voice_code = voice_mapping[voice]\r\n\r\n        loop = asyncio.new_event_loop()\r\n        asyncio.set_event_loop(loop)\r\n        loop.run_until_complete(self.text_to_speech(text, rate, pitch, voice_code))\r\n\r\n        self.progress_bar.stop()\r\n        self.play_button.config(state=tk.NORMAL)\r\n        messagebox.showinfo('完成', f'语音生成完毕，保存在{self.audio_filename}')\r\n\r\n    def start_generate_speech(self):\r\n        self.progress_bar.start()\r\n        threading.Thread(target=self.generate_speech).start()\r\n\r\n    def play_audio(self):\r\n        if hasattr(self, 'audio_filename'):\r\n            pygame.mixer.init()\r\n            pygame.mixer.music.load(self.audio_filename)\r\n            pygame.mixer.music.play()\r\n        else:\r\n            messagebox.showwarning('警告', '没有可播放的语音文件')\r\n\r\n\r\n# 定义可用的音色和对应的中文名称\r\nvoice_mapping = {\r\n    '晓晓': 'zh-CN-XiaoxiaoNeural',\r\n    '晓伊': 'zh-CN-XiaoyiNeural',\r\n    '云健': 'zh-CN-YunjianNeural',\r\n    '云希': 'zh-CN-YunxiNeural',\r\n    '云扬': 'zh-CN-YunyangNeural',\r\n    '云夏': 'zh-CN-YunxiaNeural',\r\n    '陕西方言': 'zh-CN-shaanxi-XiaoniNeural',\r\n}\r\n\r\nif __name__ == '__main__':\r\n    root = tk.Tk()\r\n    app = TTSApp(root)\r\n    root.mainloop()\r\n\r\n``` \r\n。", 'top': 0, 'createdAt': 1719482636, 'style': '', 'script': '', 'ogImage': 'https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg', 'createdDate': '2024-06-27', 'dateLabelColor': '#bc4c00'}, 'P12': {'htmlDir': 'docs/post/One-year anniversary.html', 'labels': ['恋爱日记'], 'postTitle': 'One-year anniversary', 'postUrl': 'post/One-year%20anniversary.html', 'postSourceUrl': 'https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/issues/12', 'commentNum': 0, 'wordCount': 502, 'description': "> [!NOTE]\r\n>**Happy one-year anniversary**\r\n\r\n![4729ebda3d25333694721](https://img.000828.top/file/4729ebda3d25333694721.jpg)\r\n![61c55d5ff4ff6c09adfb4](https://img.000828.top/file/61c55d5ff4ff6c09adfb4.jpg)\r\n![4ec2c5eb4983f0051589c](https://img.000828.top/file/4ec2c5eb4983f0051589c.jpg)\r\n![2a09dd675ac91a0a06bf6](https://img.000828.top/file/2a09dd675ac91a0a06bf6.jpg)\r\n`时间真快,一转眼在一起一年了,这一年的时间了 我们相互了解彼此 有开心有眼泪 相互磨合 会吵架 会冷战 也会恩爱甜蜜 嘻嘻 这些都不重要 重要的是 我还是很爱你 热爱可抵岁月漫长 😀`\r\n<!-- ##{'timestamp':1704245082}## -->。", 'top': 1, 'createdAt': 1704245082, 'style': '<style>.markdown-alert{padding:0.5rem 1rem;margin-bottom:1rem;border-left:.25em solid var(--borderColor-default,var(--color-border-default));}.markdown-alert .markdown-alert-title {display:flex;font-weight:var(--base-text-weight-medium,500);align-items:center;line-height:1;}.markdown-alert>:first-child {margin-top:0;}.markdown-alert>:last-child {margin-bottom:0;}</style><style>.markdown-alert.markdown-alert-note {border-left-color:var(--borderColor-accent-emphasis, var(--color-accent-emphasis));background-color:var(--color-accent-subtle);}.markdown-alert.markdown-alert-note .markdown-alert-title {color: var(--fgColor-accent,var(--color-accent-fg));}</style>', 'script': '', 'ogImage': 'https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg', 'createdDate': '2024-01-03', 'dateLabelColor': '#bc4c00'}, 'P11': {'htmlDir': 'docs/post/Java--mian-shi-zong-jie---chi-xu-geng-xin.html', 'labels': ['技术博客'], 'postTitle': 'Java-面试总结-持续更新', 'postUrl': 'post/Java--mian-shi-zong-jie---chi-xu-geng-xin.html', 'postSourceUrl': 'https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/issues/11', 'commentNum': 0, 'wordCount': 4846, 'description': "<a name='bVG8o'></a>\r\n## Java基础\r\n<a name='GyAoN'></a>\r\n### 集合\r\n<a name='Huyq9'></a>\r\n#### List\r\narraylist new初始容量为0 空数组 add第一个元素 扩容到10 后续每次扩容1.5倍左右 底层是数组复制来实现\r\n<a name='D81x3'></a>\r\n#### map\r\nhashmap 1.7 数组+链表 1.8数组+链表+红黑树 <br />初始容量16 负载因子0.75(意味着容量到了百分之75的时候扩容) 当出现hash冲突 会使用拉链法解决冲突 如果同一个hash结果 key不同 进入链表 如果链表长度达到8 则转化为红黑树 转换前会判断数组长度是否大于64 如果小于64则会先对数组进行扩容 hashmap每次扩容是2倍 2的次幂 \r\n<a name='zVXi1'></a>\r\n### io\r\n<a name='Lw7sM'></a>\r\n### 多线程\r\n<a name='bED23'></a>\r\n#### 开启多线程的几种方式\r\n 继承线程类或者实现接口\r\n<a name='xxVR7'></a>\r\n#### 线程的生命周期\r\n\r\n1. 准备状态 如new thred 未调用start方法时\r\n2. 就绪状态 调用了start方法 等待cpu资源\r\n3. 运行状态\r\n4. 阻塞状态 调用了sleep方法或者 wait方法\r\n5. 线程结束\r\n<a name='GEfNg'></a>\r\n#### 线程池参数\r\n\r\n1. 核心线程数\r\n2. 最大线程数\r\n3. 工作阻塞队列\r\n4. 空闲线程存活时间\r\n5. 存活时间单位\r\n6. 拒绝策略\r\n7. 线程工厂(不重要)\r\n<a name='WpeCu'></a>\r\n#### 线程池执行流程\r\n一个任务进来  先开核心线程数是否超过设置的数量 如果没有 由核心线程执行任务如果核心线程数超过了设置的数量 则加入工作队列等待 如果 工作队列满了 并且没超过最大线程数 则开启临时新线程执行 临时线程存活时间由参数控制 回收 如果工作队列满了并且超过了最大线程数 则走拒绝策略\r\n<a name='LADTg'></a>\r\n#### ThredLocal\r\n在每个线程中都有独立的一个thredlocalmap key为thredlocal value为存储的值 其中 key为弱引用 需要手动清理 否则可能会导致内存泄漏问题\r\n<a name='iu8OP'></a>\r\n#### sleep,wait\r\nsleep是thred类的方法 作用是 休眠当前线程 无需唤醒<br />wait是object类方法 作用是是当前线程阻塞等待 在无参的方法中 需要等待别人唤醒\r\n<a name='IViPI'></a>\r\n### 锁机制\r\n<a name='PRy6Z'></a>\r\n#### volatile,sychronized和reentrantLock\r\nvolatile 关键字修饰变量 可以保证变量对每个线程的可见性 不加关键字 线程中读取的变量为从主内存复制的副本 加了关键字修饰 则直接读取主内存中的值<br />sychronized jvm提供的锁 为关键字 锁住的是对象头 分为 偏向锁 轻量级锁 自旋锁 重量级锁 是可重入锁 无法实现公平锁 无需手动释放锁<br />reentrantLock 是类 java提供的锁api 底层是aqs 锁的是int类型的state值 可重入锁 可实现公平锁和非公平锁 无参构造的是非公平锁 需要手动释放锁\r\n<a name='NxzBu'></a>\r\n#### AQS\r\naqs底层是一个双向队列和一个state信号量 java juc基本都依赖aqs框架 主要维护 信号量放行的逻辑\r\n<a name='HynM0'></a>\r\n#### CAS\r\n比较并替换 可实现 乐观锁 \r\n<a name='fjAPn'></a>\r\n### 类加载机制\r\n<a name='upWzo'></a>\r\n#### 类加载过程\r\n\r\n1. 加载:加载class文件 \r\n2. 连接:1.验证 验证class文件合法性 2.准备 为变量设置内存并赋初始值 3.解析\r\n3. 初始化\r\n<a name='f2BXz'></a>\r\n#### 双亲委派机制\r\n加载类的时候 会先向父类加载器找有没有加载过这个类 如果没有 则继续往上  如果加载过了 则直接使用父类加载的结果 直到到达顶级 再向下尝试加载<br />好处  保护程序稳定 防止重复加载 防止java 核心 api被篡改 如自己定义string类\r\n<a name='mcxZ6'></a>\r\n#### 如何打破双亲委派\r\n 自定义类加载器 重写加载方法\r\n<a name='V9hvP'></a>\r\n### JVM\r\n<a name='hd8LH'></a>\r\n#### 内存区域\r\n程序计数器  线程私有 记录代码运行位置 控制流程<br />栈 分为虚拟机栈和本地方法栈 线程私有 方法开始压入栈帧 退出弹出栈帧 <br />堆 线程共享 存储对象 gc重要位置 分为 新生代和老生代 新生代分为ende区 s0 s1 <br />方法区/元空间 线程共享 存储 类信息 常量等信息<br />直接内存\r\n<a name='IjIsL'></a>\r\n#### GC\r\n判断是否为垃圾的算法<br />1.引用计数法 有对象引用时+1 引用被清理时-1 引用为0 则为垃圾 弊端 无法解决循环引用问题<br />2.可达性分析法 从gc root开始往下找 找不到的对象均为垃圾  何为gcroot? 栈中引用的对象 方法区中静态属性和常量引用的对象 被同步锁持有的对象 \r\n\r\n垃圾回收算法:<br />标记清除法 先标记需要清理的对象 再一次性回收 弊端 会造成大量的空间碎片 <br />标记复制法  将内存分为两大块 将需要回收的对象复制到空的内存块 再清理 弊端 内存消耗过大<br />标记整理法   将需要清理的内存标记 再将所有存活对象往一端移动 然后清理端边界的对象 \r\n\r\n垃圾回收器:<br />串行垃圾回收器 原始版本 stw时间长 单线程垃圾回收 适用于小内存<br />并行垃圾回收器 串行的衍生版本 唯一不同的是垃圾回收时 多线程并行 减少stw时间<br />cms<br />g1\r\n<a name='zmk00'></a>\r\n#### 频繁出现GC的原因\r\ncpu负载过高<br />大对象太多<br />老年代内存不足导致 频繁full gc \r\n<a name='ljQ8Y'></a>\r\n## spring\r\n<a name='I39Vj'></a>\r\n### ioc\r\n控制反转和依赖注入 原理是反射 \r\n<a name='Eh6nE'></a>\r\n### aop\r\n切面 原理是反射和动态代理 生成动态代理对象 可对方法执行前和执行后进行拦截做处理\r\n<a name='dR3WA'></a>\r\n### bean的作用域\r\n单例 默认 bean容器中所有bean都是唯一的<br />多例 每次获取都是一个新bean<br />requset 每个请求都是一个新bean<br />session 每个session都是一个新bean\r\n<a name='JQvsP'></a>\r\n### bean的生命周期\r\n\r\n1. 实例化\r\n2. 属性设置\r\n3. 前置处理\r\n4. 初始化处理\r\n5. 后置处理\r\n6. 使用中\r\n7. 销毁前置操作\r\n8. 死亡\r\n<a name='Humjr'></a>\r\n## springmvc\r\n<a name='biEUj'></a>\r\n### springmvc执行流程\r\n请求过来 先到 调度servlet 由调度servlet找到处理器 handmapping 然后适配处理器 然后调用处理器找到对应的控制器 然后由控制器返回视图 渲染视图  \r\n<a name='OwubK'></a>\r\n## springboot\r\n<a name='Mh9xT'></a>\r\n## springcloud\r\n\r\n1. Nacos 注册中心\r\n2. Ribbon 负载均衡\r\n3. OpenFeign 程序通信 http接口调用\r\n4. Sentinel 降级 限流 服务保护 \r\n5. Gateway 网关 鉴权\r\n6. Seata 分布式事务 二阶段提交 AT模式和TCC模式\r\n<a name='saFqN'></a>\r\n## mybatis\r\n<a name='LgOxQ'></a>\r\n## redis\r\n<a name='k21L7'></a>\r\n## mq\r\n<a name='hidFN'></a>\r\n### 事务消费\r\n<a name='uKi8v'></a>\r\n### 顺序消费\r\n<a name='sCjx0'></a>\r\n## mysql\r\n<a name='joSNR'></a>\r\n### 常见锁\r\n共享锁 读锁 排他锁 写锁 间隙锁 行锁 表锁等\r\n<a name='fKJzk'></a>\r\n### 数据引擎\r\nmyisam和innodb的区别<br />myisam 不支持事务 文件存储分为两个文件 索引文件和数据文件分开<br />innodb 支持事务 文件存储 一个文件 索引和数据都在一个文件中 mysql默认\r\n<a name='xF1l9'></a>\r\n### 索引\r\n 普通索引 唯一索引 innodb中的主键索引(聚簇索引,特殊的唯一索引),联合索引,全文索引<br /> 底层B+Tree 多叉平衡树 叶子节点中有指针相连 节点有序 <br /> 索引覆盖 所需要查询的字段都建立了索引 不需要回表查询<br /> 最左匹配原则 如果联合索引 abc三个字段 那么查询的时候必须要有a这个字段的做为条件 才会走联合索引 因为存储索引的时候是按照从左往右按大小排序的\r\n<a name='CwBPK'></a>\r\n### 事务特征\r\n \tA原子性 同时成功同时失败 <br /> \tC 一致性 事务要保持最终一致性  一致性需要 其他三个特征来保证<br /> \tI 隔离性 根据事务隔离级别控制 保证不同事务的隔离性<br /> \tD 持久性 事务最终需要持久化到数据库中  \r\n<a name='JpxEB'></a>\r\n### 事务隔离级别\r\n \t读未提交  会产生脏读  级别最低 可以读到未提交的事务<br /> \t读已提交 不可重复读  两次查询可能会产生不一样的结果<br /> \t可重复读 mysql默认 会产生幻读 每次读取结果都一样<br /> 可串行化 级别最高 并发性能低 所有事务串行进行\r\n<a name='V6Irz'></a>\r\n### mvcc\r\n在不可重复读和可重复读的事务隔离级别中有效 用来保证 事务的并发性<br />原理是通过版本链来控制 在每个表中有两个隐藏字段 一个是事务id一个是上个版本的地址快照<br />不可重复读中 每次查询都会生成新的 readView 所以会产生两次查询不一样<br />可重复读中 会使用上次的readView 所以每次读取结果都一样 \r\n<a name='xnPLQ'></a>\r\n### mysql 锁等待超时\r\n<a name='cSEgX'></a>\r\n### limit 大数据量优化\r\n<a name='MJmJe'></a>\r\n## liunx\r\n\r\nlast:20240625。", 'top': 0, 'createdAt': 1719309194, 'style': '', 'script': '', 'ogImage': 'https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg', 'createdDate': '2024-06-25', 'dateLabelColor': '#bc4c00'}, 'P10': {'htmlDir': 'docs/post/Java--xian-cheng-gong-ju.html', 'labels': ['技术博客'], 'postTitle': 'Java-线程工具', 'postUrl': 'post/Java--xian-cheng-gong-ju.html', 'postSourceUrl': 'https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/issues/10', 'commentNum': 0, 'wordCount': 3230, 'description': '1.多个线程并行执行,主线程阻塞等待所有子线程执行完(CountDownLatch实现)\r\n源码:\r\n```java\r\nimport java.util.concurrent.CountDownLatch;\r\n\r\n\r\npublic class CountDownLatchUtil {\r\n\r\n\r\n    public static void allOf(Runnable... runnableArray) {\r\n        if (arrayIsEmpty(runnableArray)) {\r\n            return;\r\n        }\r\n        CountDownLatch countDownLatch = new CountDownLatch(runnableArray.length);\r\n        for (Runnable runnable : runnableArray) {\r\n            //  建议使用线程池\r\n            new Thread(() -> {\r\n                runnable.run();\r\n                countDownLatch.countDown();\r\n            }).start();\r\n        }\r\n        try {\r\n            countDownLatch.await();\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private static <T> boolean arrayIsEmpty(T[] array) {\r\n        return array == null || array.length == 0;\r\n    }\r\n}\r\n``` \r\n 使用示例:\r\n![image](https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/assets/50692323/9c458e5e-6dbc-4e98-b47a-59714052dc6e)\r\n\r\n后面发现Java8提供了CompletableFuture也可以实现,但是感觉用起来没有自己写的简单\r\n2.多线程并行操作集合\r\n源码:\r\n```java\r\nimport java.util.ArrayList;\r\nimport java.util.Collection;\r\nimport java.util.List;\r\nimport java.util.function.Consumer;\r\n\r\n\r\npublic class AsyncHandleUtil {\r\n\r\n    private static final int DEFAULT_PAGE_SIZE = 1000;\r\n\r\n    public static <T> void asyncHandle(List<T> list, Consumer<T> action, int pageSize) {\r\n        if (collectionIsEmpty(list)) {\r\n            return;\r\n        }\r\n        int totalPage = totalPage(list.size(), pageSize);\r\n        for (int i = 0; i < totalPage; i++) {\r\n            int pageNum = i + 1;\r\n            //  建议使用线程池\r\n            new Thread(() -> {\r\n                List<T> newDataList = getListPaging(list, pageNum, pageSize);\r\n                for (T t : newDataList) {\r\n                    action.accept(t);\r\n                }\r\n            }).start();\r\n        }\r\n    }\r\n\r\n\r\n    public static <T> void asyncHandle(List<T> list, Consumer<T> action) {\r\n        asyncHandle(list, action, DEFAULT_PAGE_SIZE);\r\n    }\r\n\r\n\r\n    private static int totalPage(int totalCount, int pageSize) {\r\n        if (pageSize == 0) {\r\n            return 0;\r\n        } else {\r\n            return totalCount % pageSize == 0 ? totalCount / pageSize : totalCount / pageSize + 1;\r\n        }\r\n    }\r\n\r\n\r\n    private static boolean collectionIsEmpty(Collection<?> collection) {\r\n        return collection == null || collection.isEmpty();\r\n    }\r\n\r\n\r\n    private static <T> List<T> getListPaging(List<T> list, int pageNum, int pageSize) {\r\n        if (collectionIsEmpty(list)) {\r\n            return new ArrayList<>(0);\r\n        }\r\n        int startIndex = (pageNum - 1) * pageSize;\r\n        int endIndex = pageNum * pageSize;\r\n        int total = list.size();\r\n        int pageCount;\r\n        int num = total % pageSize;\r\n        if (num == 0) {\r\n            pageCount = total / pageSize;\r\n        } else {\r\n            pageCount = total / pageSize + 1;\r\n        }\r\n        if (pageNum == pageCount) {\r\n            endIndex = total;\r\n        }\r\n        return list.subList(startIndex, endIndex);\r\n    }\r\n}\r\n```\r\n使用示例:\r\n![image](https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/assets/50692323/728ade16-98fe-4c5a-bcce-de7e6bed5cd9)\r\n\r\n跟Java8的并行流操作差不多,但是更灵活。', 'top': 0, 'createdAt': 1719308593, 'style': '', 'script': '', 'ogImage': 'https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg', 'createdDate': '2024-06-25', 'dateLabelColor': '#bc4c00'}, 'P9': {'htmlDir': 'docs/post/The most important day.html', 'labels': ['恋爱日记'], 'postTitle': 'The most important day', 'postUrl': 'post/The%20most%20important%20day.html', 'postSourceUrl': 'https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/issues/9', 'commentNum': 0, 'wordCount': 236, 'description': "> [!NOTE]\r\n>**We're together**\r\n`Gmeek-html<img src='https://img.000828.top/file/8e00303191742684579cd.jpg' loading='lazy'>`\r\n`过程很挫折,结果很完美,这一定是人生中最幸福的一天,虽然当时还有点患得患失,虽然刚在一起就异地,但是 还是很开心 无法用言语表达的开心 😀`\r\n<!-- ##{'timestamp':1672675200}## -->。", 'top': 1, 'createdAt': 1672675200, 'style': '', 'script': '', 'ogImage': 'https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg', 'createdDate': '2023-01-03', 'dateLabelColor': '#A333D0'}, 'P8': {'htmlDir': 'docs/post/yu-ming-ji-lu.html', 'labels': ['记录'], 'postTitle': '域名记录', 'postUrl': 'post/yu-ming-ji-lu.html', 'postSourceUrl': 'https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/issues/8', 'commentNum': 0, 'wordCount': 279, 'description': '[blog.000828.top](https://blog.000828.top) 站点域名购买商:[https://www.namesilo.com/](https://www.namesilo.com/)\r\n有个羊毛可以薅 [https://customer.l53.net/](https://customer.l53.net/) \r\n注册新用户可以免费申请一个一年的域名 购买的时候 填入优惠码 **newuser**  结算等通过就可以 \r\n暂时没有测试是否支持cloudflare\r\n`000828 是个特殊的数字 我希望可以一直持有这个域名`。', 'top': 0, 'createdAt': 1719306568, 'style': '', 'script': '', 'ogImage': 'https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg', 'createdDate': '2024-06-25', 'dateLabelColor': '#bc4c00'}}, 'singeListJson': {'P7': {'htmlDir': 'docs/about.html', 'labels': ['about'], 'postTitle': '关于 | about me', 'postUrl': 'about.html', 'postSourceUrl': 'https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/issues/7', 'commentNum': 0, 'wordCount': 1294, 'description': '**自我介绍 | `Self-introduction`**\r\n \r\n> 我是一名程序员，热爱编程和技术创新。', 'top': 0, 'createdAt': 1719296343, 'style': '', 'script': '', 'ogImage': 'https://cdn.jsdelivr.net/gh/Meekdai/meekdai.github.io/logo64.jpg', 'createdDate': '2024-06-25', 'dateLabelColor': '#bc4c00'}}, 'labelColorDict': {'about': '#E99695', '人生感悟': '#583C46', '恋爱日记': '#FB944B', '技术博客': '#1D76DB', '生活日记': '#377E5D', '记录': '#D4C5F9'}, 'displayTitle': '5pyx55CG5ri4', 'faviconUrl': 'https://avatars.githubusercontent.com/u/50692323?v=4&size=64', 'postTitle': 'Java-面试总结-持续更新', 'postUrl': 'https://blog.000828.top//post/Java--mian-shi-zong-jie---chi-xu-geng-xin.html', 'description': "<a name='bVG8o'></a>\r\n## Java基础\r\n<a name='GyAoN'></a>\r\n### 集合\r\n<a name='Huyq9'></a>\r\n#### List\r\narraylist new初始容量为0 空数组 add第一个元素 扩容到10 后续每次扩容1.5倍左右 底层是数组复制来实现\r\n<a name='D81x3'></a>\r\n#### map\r\nhashmap 1.7 数组+链表 1.8数组+链表+红黑树 <br />初始容量16 负载因子0.75(意味着容量到了百分之75的时候扩容) 当出现hash冲突 会使用拉链法解决冲突 如果同一个hash结果 key不同 进入链表 如果链表长度达到8 则转化为红黑树 转换前会判断数组长度是否大于64 如果小于64则会先对数组进行扩容 hashmap每次扩容是2倍 2的次幂 \r\n<a name='zVXi1'></a>\r\n### io\r\n<a name='Lw7sM'></a>\r\n### 多线程\r\n<a name='bED23'></a>\r\n#### 开启多线程的几种方式\r\n 继承线程类或者实现接口\r\n<a name='xxVR7'></a>\r\n#### 线程的生命周期\r\n\r\n1. 准备状态 如new thred 未调用start方法时\r\n2. 就绪状态 调用了start方法 等待cpu资源\r\n3. 运行状态\r\n4. 阻塞状态 调用了sleep方法或者 wait方法\r\n5. 线程结束\r\n<a name='GEfNg'></a>\r\n#### 线程池参数\r\n\r\n1. 核心线程数\r\n2. 最大线程数\r\n3. 工作阻塞队列\r\n4. 空闲线程存活时间\r\n5. 存活时间单位\r\n6. 拒绝策略\r\n7. 线程工厂(不重要)\r\n<a name='WpeCu'></a>\r\n#### 线程池执行流程\r\n一个任务进来  先开核心线程数是否超过设置的数量 如果没有 由核心线程执行任务如果核心线程数超过了设置的数量 则加入工作队列等待 如果 工作队列满了 并且没超过最大线程数 则开启临时新线程执行 临时线程存活时间由参数控制 回收 如果工作队列满了并且超过了最大线程数 则走拒绝策略\r\n<a name='LADTg'></a>\r\n#### ThredLocal\r\n在每个线程中都有独立的一个thredlocalmap key为thredlocal value为存储的值 其中 key为弱引用 需要手动清理 否则可能会导致内存泄漏问题\r\n<a name='iu8OP'></a>\r\n#### sleep,wait\r\nsleep是thred类的方法 作用是 休眠当前线程 无需唤醒<br />wait是object类方法 作用是是当前线程阻塞等待 在无参的方法中 需要等待别人唤醒\r\n<a name='IViPI'></a>\r\n### 锁机制\r\n<a name='PRy6Z'></a>\r\n#### volatile,sychronized和reentrantLock\r\nvolatile 关键字修饰变量 可以保证变量对每个线程的可见性 不加关键字 线程中读取的变量为从主内存复制的副本 加了关键字修饰 则直接读取主内存中的值<br />sychronized jvm提供的锁 为关键字 锁住的是对象头 分为 偏向锁 轻量级锁 自旋锁 重量级锁 是可重入锁 无法实现公平锁 无需手动释放锁<br />reentrantLock 是类 java提供的锁api 底层是aqs 锁的是int类型的state值 可重入锁 可实现公平锁和非公平锁 无参构造的是非公平锁 需要手动释放锁\r\n<a name='NxzBu'></a>\r\n#### AQS\r\naqs底层是一个双向队列和一个state信号量 java juc基本都依赖aqs框架 主要维护 信号量放行的逻辑\r\n<a name='HynM0'></a>\r\n#### CAS\r\n比较并替换 可实现 乐观锁 \r\n<a name='fjAPn'></a>\r\n### 类加载机制\r\n<a name='upWzo'></a>\r\n#### 类加载过程\r\n\r\n1. 加载:加载class文件 \r\n2. 连接:1.验证 验证class文件合法性 2.准备 为变量设置内存并赋初始值 3.解析\r\n3. 初始化\r\n<a name='f2BXz'></a>\r\n#### 双亲委派机制\r\n加载类的时候 会先向父类加载器找有没有加载过这个类 如果没有 则继续往上  如果加载过了 则直接使用父类加载的结果 直到到达顶级 再向下尝试加载<br />好处  保护程序稳定 防止重复加载 防止java 核心 api被篡改 如自己定义string类\r\n<a name='mcxZ6'></a>\r\n#### 如何打破双亲委派\r\n 自定义类加载器 重写加载方法\r\n<a name='V9hvP'></a>\r\n### JVM\r\n<a name='hd8LH'></a>\r\n#### 内存区域\r\n程序计数器  线程私有 记录代码运行位置 控制流程<br />栈 分为虚拟机栈和本地方法栈 线程私有 方法开始压入栈帧 退出弹出栈帧 <br />堆 线程共享 存储对象 gc重要位置 分为 新生代和老生代 新生代分为ende区 s0 s1 <br />方法区/元空间 线程共享 存储 类信息 常量等信息<br />直接内存\r\n<a name='IjIsL'></a>\r\n#### GC\r\n判断是否为垃圾的算法<br />1.引用计数法 有对象引用时+1 引用被清理时-1 引用为0 则为垃圾 弊端 无法解决循环引用问题<br />2.可达性分析法 从gc root开始往下找 找不到的对象均为垃圾  何为gcroot? 栈中引用的对象 方法区中静态属性和常量引用的对象 被同步锁持有的对象 \r\n\r\n垃圾回收算法:<br />标记清除法 先标记需要清理的对象 再一次性回收 弊端 会造成大量的空间碎片 <br />标记复制法  将内存分为两大块 将需要回收的对象复制到空的内存块 再清理 弊端 内存消耗过大<br />标记整理法   将需要清理的内存标记 再将所有存活对象往一端移动 然后清理端边界的对象 \r\n\r\n垃圾回收器:<br />串行垃圾回收器 原始版本 stw时间长 单线程垃圾回收 适用于小内存<br />并行垃圾回收器 串行的衍生版本 唯一不同的是垃圾回收时 多线程并行 减少stw时间<br />cms<br />g1\r\n<a name='zmk00'></a>\r\n#### 频繁出现GC的原因\r\ncpu负载过高<br />大对象太多<br />老年代内存不足导致 频繁full gc \r\n<a name='ljQ8Y'></a>\r\n## spring\r\n<a name='I39Vj'></a>\r\n### ioc\r\n控制反转和依赖注入 原理是反射 \r\n<a name='Eh6nE'></a>\r\n### aop\r\n切面 原理是反射和动态代理 生成动态代理对象 可对方法执行前和执行后进行拦截做处理\r\n<a name='dR3WA'></a>\r\n### bean的作用域\r\n单例 默认 bean容器中所有bean都是唯一的<br />多例 每次获取都是一个新bean<br />requset 每个请求都是一个新bean<br />session 每个session都是一个新bean\r\n<a name='JQvsP'></a>\r\n### bean的生命周期\r\n\r\n1. 实例化\r\n2. 属性设置\r\n3. 前置处理\r\n4. 初始化处理\r\n5. 后置处理\r\n6. 使用中\r\n7. 销毁前置操作\r\n8. 死亡\r\n<a name='Humjr'></a>\r\n## springmvc\r\n<a name='biEUj'></a>\r\n### springmvc执行流程\r\n请求过来 先到 调度servlet 由调度servlet找到处理器 handmapping 然后适配处理器 然后调用处理器找到对应的控制器 然后由控制器返回视图 渲染视图  \r\n<a name='OwubK'></a>\r\n## springboot\r\n<a name='Mh9xT'></a>\r\n## springcloud\r\n\r\n1. Nacos 注册中心\r\n2. Ribbon 负载均衡\r\n3. OpenFeign 程序通信 http接口调用\r\n4. Sentinel 降级 限流 服务保护 \r\n5. Gateway 网关 鉴权\r\n6. Seata 分布式事务 二阶段提交 AT模式和TCC模式\r\n<a name='saFqN'></a>\r\n## mybatis\r\n<a name='LgOxQ'></a>\r\n## redis\r\n<a name='k21L7'></a>\r\n## mq\r\n<a name='hidFN'></a>\r\n### 事务消费\r\n<a name='uKi8v'></a>\r\n### 顺序消费\r\n<a name='sCjx0'></a>\r\n## mysql\r\n<a name='joSNR'></a>\r\n### 常见锁\r\n共享锁 读锁 排他锁 写锁 间隙锁 行锁 表锁等\r\n<a name='fKJzk'></a>\r\n### 数据引擎\r\nmyisam和innodb的区别<br />myisam 不支持事务 文件存储分为两个文件 索引文件和数据文件分开<br />innodb 支持事务 文件存储 一个文件 索引和数据都在一个文件中 mysql默认\r\n<a name='xF1l9'></a>\r\n### 索引\r\n 普通索引 唯一索引 innodb中的主键索引(聚簇索引,特殊的唯一索引),联合索引,全文索引<br /> 底层B+Tree 多叉平衡树 叶子节点中有指针相连 节点有序 <br /> 索引覆盖 所需要查询的字段都建立了索引 不需要回表查询<br /> 最左匹配原则 如果联合索引 abc三个字段 那么查询的时候必须要有a这个字段的做为条件 才会走联合索引 因为存储索引的时候是按照从左往右按大小排序的\r\n<a name='CwBPK'></a>\r\n### 事务特征\r\n \tA原子性 同时成功同时失败 <br /> \tC 一致性 事务要保持最终一致性  一致性需要 其他三个特征来保证<br /> \tI 隔离性 根据事务隔离级别控制 保证不同事务的隔离性<br /> \tD 持久性 事务最终需要持久化到数据库中  \r\n<a name='JpxEB'></a>\r\n### 事务隔离级别\r\n \t读未提交  会产生脏读  级别最低 可以读到未提交的事务<br /> \t读已提交 不可重复读  两次查询可能会产生不一样的结果<br /> \t可重复读 mysql默认 会产生幻读 每次读取结果都一样<br /> 可串行化 级别最高 并发性能低 所有事务串行进行\r\n<a name='V6Irz'></a>\r\n### mvcc\r\n在不可重复读和可重复读的事务隔离级别中有效 用来保证 事务的并发性<br />原理是通过版本链来控制 在每个表中有两个隐藏字段 一个是事务id一个是上个版本的地址快照<br />不可重复读中 每次查询都会生成新的 readView 所以会产生两次查询不一样<br />可重复读中 会使用上次的readView 所以每次读取结果都一样 \r\n<a name='xnPLQ'></a>\r\n### mysql 锁等待超时\r\n<a name='cSEgX'></a>\r\n### limit 大数据量优化\r\n<a name='MJmJe'></a>\r\n## liunx\r\n\r\nlast:20240625。", 'postBody': '<p><a name="user-content-bvg8o"></a></p>\n<h2>Java基础</h2>\n<p><a name="user-content-gyaon"></a></p>\n<h3>集合</h3>\n<p><a name="user-content-huyq9"></a></p>\n<h4>List</h4>\n<p>arraylist new初始容量为0 空数组 add第一个元素 扩容到10 后续每次扩容1.5倍左右 底层是数组复制来实现<br>\n<a name="user-content-d81x3"></a></p>\n<h4>map</h4>\n<p>hashmap 1.7 数组+链表 1.8数组+链表+红黑树 <br>初始容量16 负载因子0.75(意味着容量到了百分之75的时候扩容) 当出现hash冲突 会使用拉链法解决冲突 如果同一个hash结果 key不同 进入链表 如果链表长度达到8 则转化为红黑树 转换前会判断数组长度是否大于64 如果小于64则会先对数组进行扩容 hashmap每次扩容是2倍 2的次幂<br>\n<a name="user-content-zvxi1"></a></p>\n<h3>io</h3>\n<p><a name="user-content-lw7sm"></a></p>\n<h3>多线程</h3>\n<p><a name="user-content-bed23"></a></p>\n<h4>开启多线程的几种方式</h4>\n<p>继承线程类或者实现接口<br>\n<a name="user-content-xxvr7"></a></p>\n<h4>线程的生命周期</h4>\n<ol>\n<li>准备状态 如new thred 未调用start方法时</li>\n<li>就绪状态 调用了start方法 等待cpu资源</li>\n<li>运行状态</li>\n<li>阻塞状态 调用了sleep方法或者 wait方法</li>\n<li>线程结束<br>\n<a name="user-content-gefng"></a></li>\n</ol>\n<h4>线程池参数</h4>\n<ol>\n<li>核心线程数</li>\n<li>最大线程数</li>\n<li>工作阻塞队列</li>\n<li>空闲线程存活时间</li>\n<li>存活时间单位</li>\n<li>拒绝策略</li>\n<li>线程工厂(不重要)<br>\n<a name="user-content-wpecu"></a></li>\n</ol>\n<h4>线程池执行流程</h4>\n<p>一个任务进来  先开核心线程数是否超过设置的数量 如果没有 由核心线程执行任务如果核心线程数超过了设置的数量 则加入工作队列等待 如果 工作队列满了 并且没超过最大线程数 则开启临时新线程执行 临时线程存活时间由参数控制 回收 如果工作队列满了并且超过了最大线程数 则走拒绝策略<br>\n<a name="user-content-ladtg"></a></p>\n<h4>ThredLocal</h4>\n<p>在每个线程中都有独立的一个thredlocalmap key为thredlocal value为存储的值 其中 key为弱引用 需要手动清理 否则可能会导致内存泄漏问题<br>\n<a name="user-content-iu8op"></a></p>\n<h4>sleep,wait</h4>\n<p>sleep是thred类的方法 作用是 休眠当前线程 无需唤醒<br>wait是object类方法 作用是是当前线程阻塞等待 在无参的方法中 需要等待别人唤醒<br>\n<a name="user-content-ivipi"></a></p>\n<h3>锁机制</h3>\n<p><a name="user-content-pry6z"></a></p>\n<h4>volatile,sychronized和reentrantLock</h4>\n<p>volatile 关键字修饰变量 可以保证变量对每个线程的可见性 不加关键字 线程中读取的变量为从主内存复制的副本 加了关键字修饰 则直接读取主内存中的值<br>sychronized jvm提供的锁 为关键字 锁住的是对象头 分为 偏向锁 轻量级锁 自旋锁 重量级锁 是可重入锁 无法实现公平锁 无需手动释放锁<br>reentrantLock 是类 java提供的锁api 底层是aqs 锁的是int类型的state值 可重入锁 可实现公平锁和非公平锁 无参构造的是非公平锁 需要手动释放锁<br>\n<a name="user-content-nxzbu"></a></p>\n<h4>AQS</h4>\n<p>aqs底层是一个双向队列和一个state信号量 java juc基本都依赖aqs框架 主要维护 信号量放行的逻辑<br>\n<a name="user-content-hynm0"></a></p>\n<h4>CAS</h4>\n<p>比较并替换 可实现 乐观锁<br>\n<a name="user-content-fjapn"></a></p>\n<h3>类加载机制</h3>\n<p><a name="user-content-upwzo"></a></p>\n<h4>类加载过程</h4>\n<ol>\n<li>加载:加载class文件</li>\n<li>连接:1.验证 验证class文件合法性 2.准备 为变量设置内存并赋初始值 3.解析</li>\n<li>初始化<br>\n<a name="user-content-f2bxz"></a></li>\n</ol>\n<h4>双亲委派机制</h4>\n<p>加载类的时候 会先向父类加载器找有没有加载过这个类 如果没有 则继续往上  如果加载过了 则直接使用父类加载的结果 直到到达顶级 再向下尝试加载<br>好处  保护程序稳定 防止重复加载 防止java 核心 api被篡改 如自己定义string类<br>\n<a name="user-content-mcxz6"></a></p>\n<h4>如何打破双亲委派</h4>\n<p>自定义类加载器 重写加载方法<br>\n<a name="user-content-v9hvp"></a></p>\n<h3>JVM</h3>\n<p><a name="user-content-hd8lh"></a></p>\n<h4>内存区域</h4>\n<p>程序计数器  线程私有 记录代码运行位置 控制流程<br>栈 分为虚拟机栈和本地方法栈 线程私有 方法开始压入栈帧 退出弹出栈帧 <br>堆 线程共享 存储对象 gc重要位置 分为 新生代和老生代 新生代分为ende区 s0 s1 <br>方法区/元空间 线程共享 存储 类信息 常量等信息<br>直接内存<br>\n<a name="user-content-ijisl"></a></p>\n<h4>GC</h4>\n<p>判断是否为垃圾的算法<br>1.引用计数法 有对象引用时+1 引用被清理时-1 引用为0 则为垃圾 弊端 无法解决循环引用问题<br>2.可达性分析法 从gc root开始往下找 找不到的对象均为垃圾  何为gcroot? 栈中引用的对象 方法区中静态属性和常量引用的对象 被同步锁持有的对象</p>\n<p>垃圾回收算法:<br>标记清除法 先标记需要清理的对象 再一次性回收 弊端 会造成大量的空间碎片 <br>标记复制法  将内存分为两大块 将需要回收的对象复制到空的内存块 再清理 弊端 内存消耗过大<br>标记整理法   将需要清理的内存标记 再将所有存活对象往一端移动 然后清理端边界的对象</p>\n<p>垃圾回收器:<br>串行垃圾回收器 原始版本 stw时间长 单线程垃圾回收 适用于小内存<br>并行垃圾回收器 串行的衍生版本 唯一不同的是垃圾回收时 多线程并行 减少stw时间<br>cms<br>g1<br>\n<a name="user-content-zmk00"></a></p>\n<h4>频繁出现GC的原因</h4>\n<p>cpu负载过高<br>大对象太多<br>老年代内存不足导致 频繁full gc<br>\n<a name="user-content-ljq8y"></a></p>\n<h2>spring</h2>\n<p><a name="user-content-i39vj"></a></p>\n<h3>ioc</h3>\n<p>控制反转和依赖注入 原理是反射<br>\n<a name="user-content-eh6ne"></a></p>\n<h3>aop</h3>\n<p>切面 原理是反射和动态代理 生成动态代理对象 可对方法执行前和执行后进行拦截做处理<br>\n<a name="user-content-dr3wa"></a></p>\n<h3>bean的作用域</h3>\n<p>单例 默认 bean容器中所有bean都是唯一的<br>多例 每次获取都是一个新bean<br>requset 每个请求都是一个新bean<br>session 每个session都是一个新bean<br>\n<a name="user-content-jqvsp"></a></p>\n<h3>bean的生命周期</h3>\n<ol>\n<li>实例化</li>\n<li>属性设置</li>\n<li>前置处理</li>\n<li>初始化处理</li>\n<li>后置处理</li>\n<li>使用中</li>\n<li>销毁前置操作</li>\n<li>死亡<br>\n<a name="user-content-humjr"></a></li>\n</ol>\n<h2>springmvc</h2>\n<p><a name="user-content-bieuj"></a></p>\n<h3>springmvc执行流程</h3>\n<p>请求过来 先到 调度servlet 由调度servlet找到处理器 handmapping 然后适配处理器 然后调用处理器找到对应的控制器 然后由控制器返回视图 渲染视图<br>\n<a name="user-content-owubk"></a></p>\n<h2>springboot</h2>\n<p><a name="user-content-mh9xt"></a></p>\n<h2>springcloud</h2>\n<ol>\n<li>Nacos 注册中心</li>\n<li>Ribbon 负载均衡</li>\n<li>OpenFeign 程序通信 http接口调用</li>\n<li>Sentinel 降级 限流 服务保护</li>\n<li>Gateway 网关 鉴权</li>\n<li>Seata 分布式事务 二阶段提交 AT模式和TCC模式<br>\n<a name="user-content-safqn"></a></li>\n</ol>\n<h2>mybatis</h2>\n<p><a name="user-content-lgoxq"></a></p>\n<h2>redis</h2>\n<p><a name="user-content-k21l7"></a></p>\n<h2>mq</h2>\n<p><a name="user-content-hidfn"></a></p>\n<h3>事务消费</h3>\n<p><a name="user-content-uki8v"></a></p>\n<h3>顺序消费</h3>\n<p><a name="user-content-scjx0"></a></p>\n<h2>mysql</h2>\n<p><a name="user-content-josnr"></a></p>\n<h3>常见锁</h3>\n<p>共享锁 读锁 排他锁 写锁 间隙锁 行锁 表锁等<br>\n<a name="user-content-fkjzk"></a></p>\n<h3>数据引擎</h3>\n<p>myisam和innodb的区别<br>myisam 不支持事务 文件存储分为两个文件 索引文件和数据文件分开<br>innodb 支持事务 文件存储 一个文件 索引和数据都在一个文件中 mysql默认<br>\n<a name="user-content-xf1l9"></a></p>\n<h3>索引</h3>\n<p>普通索引 唯一索引 innodb中的主键索引(聚簇索引,特殊的唯一索引),联合索引,全文索引<br> 底层B+Tree 多叉平衡树 叶子节点中有指针相连 节点有序 <br> 索引覆盖 所需要查询的字段都建立了索引 不需要回表查询<br> 最左匹配原则 如果联合索引 abc三个字段 那么查询的时候必须要有a这个字段的做为条件 才会走联合索引 因为存储索引的时候是按照从左往右按大小排序的<br>\n<a name="user-content-cwbpk"></a></p>\n<h3>事务特征</h3>\n<pre class="notranslate"><code class="notranslate">A原子性 同时成功同时失败 &lt;br /&gt; \tC 一致性 事务要保持最终一致性  一致性需要 其他三个特征来保证&lt;br /&gt; \tI 隔离性 根据事务隔离级别控制 保证不同事务的隔离性&lt;br /&gt; \tD 持久性 事务最终需要持久化到数据库中  \n</code></pre>\n<p><a name="user-content-jpxeb"></a></p>\n<h3>事务隔离级别</h3>\n<pre class="notranslate"><code class="notranslate">读未提交  会产生脏读  级别最低 可以读到未提交的事务&lt;br /&gt; \t读已提交 不可重复读  两次查询可能会产生不一样的结果&lt;br /&gt; \t可重复读 mysql默认 会产生幻读 每次读取结果都一样&lt;br /&gt; 可串行化 级别最高 并发性能低 所有事务串行进行\n</code></pre>\n<p><a name="user-content-v6irz"></a></p>\n<h3>mvcc</h3>\n<p>在不可重复读和可重复读的事务隔离级别中有效 用来保证 事务的并发性<br>原理是通过版本链来控制 在每个表中有两个隐藏字段 一个是事务id一个是上个版本的地址快照<br>不可重复读中 每次查询都会生成新的 readView 所以会产生两次查询不一样<br>可重复读中 会使用上次的readView 所以每次读取结果都一样<br>\n<a name="user-content-xnplq"></a></p>\n<h3>mysql 锁等待超时</h3>\n<p><a name="user-content-csegx"></a></p>\n<h3>limit 大数据量优化</h3>\n<p><a name="user-content-mjmje"></a></p>\n<h2>liunx</h2>\n<p>last:20240625</p>', 'commentNum': 0, 'top': 0, 'postSourceUrl': 'https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/issues/11', 'repoName': '5pyx55CG5ri4/5pyx55CG5ri4.github.io', 'highlight': 0}
</div>
<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>
</div>
    <div id="footer"><div class="mus">
  <span>她最爱的歌:Head In The Clouds - Hayd</span>
  <audio src="https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/assets/50692323/e002b7aa-e9e5-464e-a461-0d3f3506db1e" controls></audio>
</div>
<p>
<span id="runday"></span></br>
</p>
Copyright © <span id="year"></span><span> 💖你就像💖生命</span></br>
<script>
if("01/03/2023"!=""){
    var now=new Date();
    var startSite=new Date("01/03/2023");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("year").innerHTML=now.getFullYear();
    if(""!=""){document.getElementById("runday").innerHTML=" • "+"网站已经运行"+diffDay+"天";}
    else{document.getElementById("runday").innerHTML="网站已经运行"+diffDay+"天";}
}
</script>
<style>
/* 定义整个播放器的样式 */
.player {
    margin-top: 50px; /* 距离上方50px */
    height: 350px; /* 高度为350px */
    width: 800px; /* 宽度为800px */
    background-color: rgba(216, 218, 221, 0.5); /* 背景颜色为rgba(216, 218, 221, 0.5) */
    border-radius: 10px; /* 边框半径为10px */
}
 
/* 定义封面的样式 */
.player .cover {
    display: inline-block; /* 内部元素呈现为块级元素 */
    height: 250px; /* 高度为250px */
    width: 250px; /* 宽度为250px */
    margin-left: 30px; /* 距离左侧30px */
    margin-top: 30px; /* 距离上方30px */
    overflow: hidden; /* 溢出部分隐藏 */
    border-radius: 10px; /* 边框半径为10px */
}
 
/* 定义歌曲信息的样式 */
.song {
    position: absolute; /* 绝对定位 */
    margin-left: 50px; /* 距离左侧50px */
    margin-top: 20px; /* 距离上方20px */
    left: 250px; /* 左侧距离为250px */
    top: 150px; /* 上方距离为150px */
    height: 250px; /* 高度为250px */
    width: 400px; /* 宽度为400px */
    overflow: auto; /* 溢出部分自动滚动 */
}
 
/* 隐藏滚动条 */
div::-webkit-scrollbar {
    display: none;
}
 
/* 定义p标签的字体样式 */
.song p {
    font-family: "楷体";
    margin: 5px; /* 上下左右各留出5px的间距 */
}
 
/* 定义h2标签的字体样式 */
.song h2 {
    font-family: "楷体";
}
 
/* 设置音频样式 */
audio {
    width: 100%; /* 宽度为100% */
    height: 50px; /* 高度为50px */
    border-radius: 10px; /* 边框半径为10px */
}
 
/* 设置音频播放进度条的颜色 */
audio::-webkit-media-controls-progress-bar {
    background-color: #000;
}
 
/* 定义播放器的背景颜色 */
.player {
    /* background: linear-gradient(to bottom, #304352, #d7d2cc); */
    background-color: rgba(238, 238, 238, 0.2); /* 背景颜色为rgba(238, 238, 238, 0.2) */
}
 
/* 隐藏音频播放器的背景颜色 */
audio::-webkit-media-controls-enclosure {
    background-color: rgba(216, 218, 221, 0.0);
}
</style></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n\n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);

function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","5pyx55CG5ri4/5pyx55CG5ri4.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}
</script>


</html>
