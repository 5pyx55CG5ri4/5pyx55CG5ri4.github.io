<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>5pyx55CG5ri4</title><link>https://blog.000828.top/</link><description>永远相信美好的事情即将发生</description><copyright>5pyx55CG5ri4</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/50692323?v=4&amp;size=64</url><title>avatar</title><link>https://blog.000828.top/</link></image><lastBuildDate>Wed, 17 Jul 2024 10:22:54 +0000</lastBuildDate><managingEditor>5pyx55CG5ri4</managingEditor><ttl>60</ttl><webMaster>5pyx55CG5ri4</webMaster><item><title>25 years old</title><link>https://blog.000828.top//post/25%20years%20old.html</link><description>**25岁了,收到了这辈子目前为止最生猛的礼物**&#13;
&#13;
**1.  主机+显示器+键鼠全家桶全配齐了 我应该是世界上最幸福的男人吧 是男人都得羡慕我 😀**&#13;
&#13;
`Gmeek-html&lt;img src='https://img.000828.top/file/73c8722d6d25b3125492a.jpg'&gt;`&#13;
&#13;
**2. 荷花(真花)+荷花(烟) 😀**&#13;
&#13;
`Gmeek-html&lt;img src='https://img.000828.top/file/778375e35b72ff81f7df7.jpg'&gt;`&#13;
&#13;
**3. GG Bond 蛋糕 我 想一直做你的英雄 不止是童话里 😍**&#13;
&#13;
`Gmeek-html&lt;img src='https://img.000828.top/file/ee9408db9cb94520edd40.jpg'&gt;`&#13;
&#13;
**4. 去年的今天,也是你陪我一起 仪式感拉满**&#13;
&#13;
`Gmeek-html&lt;img src='https://img.000828.top/file/215eb0b78642469d7d35f.jpg'&gt;`&#13;
&#13;
&gt; [!NOTE]&#13;
&gt; **感谢我的宝贝**&#13;
&#13;
&#13;
&lt;!-- ##{'timestamp':1721125039}## --&gt;&#13;
。</description><guid isPermaLink="true">https://blog.000828.top//post/25%20years%20old.html</guid><pubDate>Wed, 17 Jul 2024 10:19:51 +0000</pubDate></item><item><title>18 months</title><link>https://blog.000828.top//post/18%20months.html</link><description>在一起的第18个月&#13;
最近我们的感情出了点问题 频繁吵架&#13;
她觉得我变了 感受不到安全感了 **深刻反思** &#13;
也许是到了平淡期 但是我想找到平衡点 &#13;
后面也聊了很久 说了很多内心的想法  我想跟她好好的并且能一直走下去&#13;
&#13;
### 给她买的荔枝花束 带她去吃了最近想吃的火锅 😀&#13;
![0af196511eb70adc54dc1](https://img.000828.top/file/0af196511eb70adc54dc1.jpg)&#13;
![b86986b17106adda1db42](https://img.000828.top/file/b86986b17106adda1db42.jpg)&#13;
&#13;
最后 18个月快乐~&#13;
&#13;
&lt;!-- ##{'timestamp':1719983839}## --&gt;。</description><guid isPermaLink="true">https://blog.000828.top//post/18%20months.html</guid><pubDate>Wed, 03 Jul 2024 05:17:19 +0000</pubDate></item><item><title>基于edge-tts的文字转语音工具-python</title><link>https://blog.000828.top//post/ji-yu-edge-tts-de-wen-zi-zhuan-yu-yin-gong-ju--python.html</link><description>最近想整点副业 想做小说推文 找了些文字转语音工具 发现大部分都有字数限制 于是自己开发了一个 基于开源的edge-tts 带图形化界面(虽然有点丑)&#13;
&#13;
仅支持windows&#13;
&#13;
支持文字转语音 调整音色 语速 语调&#13;
&#13;
&#13;
[github地址](https://github.com/5pyx55CG5ri4/TTS)&#13;
&#13;
[releases](https://github.com/5pyx55CG5ri4/TTS/releases)&#13;
```python&#13;
import asyncio&#13;
import threading&#13;
import tkinter as tk&#13;
from datetime import datetime&#13;
from tkinter import messagebox, scrolledtext, ttk&#13;
&#13;
import edge_tts&#13;
import pygame&#13;
&#13;
&#13;
class TTSApp:&#13;
    def __init__(self, root):&#13;
        self.root = root&#13;
        self.root.title('小说推文工具')&#13;
        self.root.geometry('600x700')&#13;
&#13;
        self.notebook = ttk.Notebook(self.root)&#13;
        self.notebook.pack(fill=tk.BOTH, expand=True)&#13;
&#13;
        self.tts_page = TTSPage(self.notebook)&#13;
&#13;
        self.notebook.add(self.tts_page, text='TTS(文字转语音)')&#13;
&#13;
&#13;
class TTSPage(tk.Frame):&#13;
    def __init__(self, parent):&#13;
        super().__init__(parent)&#13;
&#13;
        self.create_widgets()&#13;
&#13;
    def create_widgets(self):&#13;
        title_label = tk.Label(self, text='TTS(文字转语音)', font=('Helvetica', 24, 'bold'))&#13;
        title_label.pack(pady=10)&#13;
&#13;
        text_frame = tk.Frame(self)&#13;
        text_frame.pack(padx=10, pady=10)&#13;
&#13;
        self.text_area = scrolledtext.ScrolledText(text_frame, wrap=tk.WORD, width=60, height=15,&#13;
                                                   font=('Helvetica', 12))&#13;
        self.text_area.pack(padx=10, pady=10)&#13;
&#13;
        control_frame = tk.Frame(self)&#13;
        control_frame.pack(padx=10, pady=5)&#13;
&#13;
        rate_label = tk.Label(control_frame, text='语速:', font=('Helvetica', 12))&#13;
        rate_label.grid(row=0, column=0, padx=5)&#13;
&#13;
        self.rate_slider = tk.Scale(control_frame, from_=-100, to=100, orient=tk.HORIZONTAL, length=200)&#13;
        self.rate_slider.grid(row=0, column=1, padx=5)&#13;
&#13;
        pitch_label = tk.Label(control_frame, text='语调:', font=('Helvetica', 12))&#13;
        pitch_label.grid(row=1, column=0, padx=5)&#13;
&#13;
        self.pitch_slider = tk.Scale(control_frame, from_=-50, to=50, orient=tk.HORIZONTAL, length=200)&#13;
        self.pitch_slider.grid(row=1, column=1, padx=5)&#13;
&#13;
        voice_label = tk.Label(control_frame, text='音色:', font=('Helvetica', 12))&#13;
        voice_label.grid(row=2, column=0, padx=5)&#13;
&#13;
        self.voice_combobox = tk.StringVar()&#13;
        self.voice_combobox.set('晓晓')&#13;
        self.voice_dropdown = tk.OptionMenu(control_frame, self.voice_combobox, '晓晓', '晓伊', '云健', '云希', '云扬',&#13;
                                            '云夏', '陕西方言')&#13;
        self.voice_dropdown.config(font=('Helvetica', 12))&#13;
        self.voice_dropdown.grid(row=2, column=1, padx=5)&#13;
&#13;
        generate_button = tk.Button(self, text='生成语音', command=self.start_generate_speech,&#13;
                                    font=('Helvetica', 14, 'bold'),&#13;
                                    bg='#4CAF50', fg='white')&#13;
        generate_button.pack(padx=10, pady=10)&#13;
&#13;
        self.progress_bar = ttk.Progressbar(self, mode='indeterminate')&#13;
        self.progress_bar.pack(padx=10, pady=10, fill=tk.X)&#13;
&#13;
        self.play_button = tk.Button(self, text='播放语音', command=self.play_audio, font=('Helvetica', 14, 'bold'),&#13;
                                     bg='#4CAF50', fg='white', state=tk.DISABLED)&#13;
        self.play_button.pack(padx=10, pady=10)&#13;
&#13;
    async def text_to_speech(self, text, rate, pitch, voice):&#13;
        filename = datetime.now().strftime('%Y%m%d_%H%M%S_%f') + '.mp3'&#13;
        communicate = edge_tts.Communicate(text, voice, rate=rate, pitch=pitch)&#13;
        await communicate.save(filename)&#13;
        self.audio_filename = filename&#13;
&#13;
    def generate_speech(self):&#13;
        text = self.text_area.get('1.0', tk.END).strip()&#13;
        if not text:&#13;
            messagebox.showwarning('警告', '请输入文本内容')&#13;
            return&#13;
&#13;
        rate = f'{self.rate_slider.get():+d}%'&#13;
        pitch_value = self.pitch_slider.get()&#13;
        pitch = f'{pitch_value:+d}Hz' if pitch_value != 0 else '+0Hz'  # 如果pitch为0，则设置为字符串'0Hz'&#13;
        voice = self.voice_combobox.get()&#13;
        voice_code = voice_mapping[voice]&#13;
&#13;
        loop = asyncio.new_event_loop()&#13;
        asyncio.set_event_loop(loop)&#13;
        loop.run_until_complete(self.text_to_speech(text, rate, pitch, voice_code))&#13;
&#13;
        self.progress_bar.stop()&#13;
        self.play_button.config(state=tk.NORMAL)&#13;
        messagebox.showinfo('完成', f'语音生成完毕，保存在{self.audio_filename}')&#13;
&#13;
    def start_generate_speech(self):&#13;
        self.progress_bar.start()&#13;
        threading.Thread(target=self.generate_speech).start()&#13;
&#13;
    def play_audio(self):&#13;
        if hasattr(self, 'audio_filename'):&#13;
            pygame.mixer.init()&#13;
            pygame.mixer.music.load(self.audio_filename)&#13;
            pygame.mixer.music.play()&#13;
        else:&#13;
            messagebox.showwarning('警告', '没有可播放的语音文件')&#13;
&#13;
&#13;
# 定义可用的音色和对应的中文名称&#13;
voice_mapping = {&#13;
    '晓晓': 'zh-CN-XiaoxiaoNeural',&#13;
    '晓伊': 'zh-CN-XiaoyiNeural',&#13;
    '云健': 'zh-CN-YunjianNeural',&#13;
    '云希': 'zh-CN-YunxiNeural',&#13;
    '云扬': 'zh-CN-YunyangNeural',&#13;
    '云夏': 'zh-CN-YunxiaNeural',&#13;
    '陕西方言': 'zh-CN-shaanxi-XiaoniNeural',&#13;
}&#13;
&#13;
if __name__ == '__main__':&#13;
    root = tk.Tk()&#13;
    app = TTSApp(root)&#13;
    root.mainloop()&#13;
&#13;
``` &#13;
。</description><guid isPermaLink="true">https://blog.000828.top//post/ji-yu-edge-tts-de-wen-zi-zhuan-yu-yin-gong-ju--python.html</guid><pubDate>Thu, 27 Jun 2024 10:03:56 +0000</pubDate></item><item><title>Java-面试总结-持续更新</title><link>https://blog.000828.top//post/Java--mian-shi-zong-jie---chi-xu-geng-xin.html</link><description>&lt;a name='bVG8o'&gt;&lt;/a&gt;&#13;
## Java基础&#13;
&lt;a name='GyAoN'&gt;&lt;/a&gt;&#13;
### 集合&#13;
&lt;a name='Huyq9'&gt;&lt;/a&gt;&#13;
#### List&#13;
arraylist new初始容量为0 空数组 add第一个元素 扩容到10 后续每次扩容1.5倍左右 底层是数组复制来实现&#13;
&lt;a name='D81x3'&gt;&lt;/a&gt;&#13;
#### map&#13;
hashmap 1.7 数组+链表 1.8数组+链表+红黑树 &lt;br /&gt;初始容量16 负载因子0.75(意味着容量到了百分之75的时候扩容) 当出现hash冲突 会使用拉链法解决冲突 如果同一个hash结果 key不同 进入链表 如果链表长度达到8 则转化为红黑树 转换前会判断数组长度是否大于64 如果小于64则会先对数组进行扩容 hashmap每次扩容是2倍 2的次幂 &#13;
&lt;a name='zVXi1'&gt;&lt;/a&gt;&#13;
### io&#13;
&lt;a name='Lw7sM'&gt;&lt;/a&gt;&#13;
### 多线程&#13;
&lt;a name='bED23'&gt;&lt;/a&gt;&#13;
#### 开启多线程的几种方式&#13;
 继承线程类或者实现接口&#13;
&lt;a name='xxVR7'&gt;&lt;/a&gt;&#13;
#### 线程的生命周期&#13;
&#13;
1. 准备状态 如new thred 未调用start方法时&#13;
2. 就绪状态 调用了start方法 等待cpu资源&#13;
3. 运行状态&#13;
4. 阻塞状态 调用了sleep方法或者 wait方法&#13;
5. 线程结束&#13;
&lt;a name='GEfNg'&gt;&lt;/a&gt;&#13;
#### 线程池参数&#13;
&#13;
1. 核心线程数&#13;
2. 最大线程数&#13;
3. 工作阻塞队列&#13;
4. 空闲线程存活时间&#13;
5. 存活时间单位&#13;
6. 拒绝策略&#13;
7. 线程工厂(不重要)&#13;
&lt;a name='WpeCu'&gt;&lt;/a&gt;&#13;
#### 线程池执行流程&#13;
一个任务进来  先开核心线程数是否超过设置的数量 如果没有 由核心线程执行任务如果核心线程数超过了设置的数量 则加入工作队列等待 如果 工作队列满了 并且没超过最大线程数 则开启临时新线程执行 临时线程存活时间由参数控制 回收 如果工作队列满了并且超过了最大线程数 则走拒绝策略&#13;
&lt;a name='LADTg'&gt;&lt;/a&gt;&#13;
#### ThredLocal&#13;
在每个线程中都有独立的一个thredlocalmap key为thredlocal value为存储的值 其中 key为弱引用 需要手动清理 否则可能会导致内存泄漏问题&#13;
&lt;a name='iu8OP'&gt;&lt;/a&gt;&#13;
#### sleep,wait&#13;
sleep是thred类的方法 作用是 休眠当前线程 无需唤醒&lt;br /&gt;wait是object类方法 作用是是当前线程阻塞等待 在无参的方法中 需要等待别人唤醒&#13;
&lt;a name='IViPI'&gt;&lt;/a&gt;&#13;
### 锁机制&#13;
&lt;a name='PRy6Z'&gt;&lt;/a&gt;&#13;
#### volatile,sychronized和reentrantLock&#13;
volatile 关键字修饰变量 可以保证变量对每个线程的可见性 不加关键字 线程中读取的变量为从主内存复制的副本 加了关键字修饰 则直接读取主内存中的值&lt;br /&gt;sychronized jvm提供的锁 为关键字 锁住的是对象头 分为 偏向锁 轻量级锁 自旋锁 重量级锁 是可重入锁 无法实现公平锁 无需手动释放锁&lt;br /&gt;reentrantLock 是类 java提供的锁api 底层是aqs 锁的是int类型的state值 可重入锁 可实现公平锁和非公平锁 无参构造的是非公平锁 需要手动释放锁&#13;
&lt;a name='NxzBu'&gt;&lt;/a&gt;&#13;
#### AQS&#13;
aqs底层是一个双向队列和一个state信号量 java juc基本都依赖aqs框架 主要维护 信号量放行的逻辑&#13;
&lt;a name='HynM0'&gt;&lt;/a&gt;&#13;
#### CAS&#13;
比较并替换 可实现 乐观锁 &#13;
&lt;a name='fjAPn'&gt;&lt;/a&gt;&#13;
### 类加载机制&#13;
&lt;a name='upWzo'&gt;&lt;/a&gt;&#13;
#### 类加载过程&#13;
&#13;
1. 加载:加载class文件 &#13;
2. 连接:1.验证 验证class文件合法性 2.准备 为变量设置内存并赋初始值 3.解析&#13;
3. 初始化&#13;
&lt;a name='f2BXz'&gt;&lt;/a&gt;&#13;
#### 双亲委派机制&#13;
加载类的时候 会先向父类加载器找有没有加载过这个类 如果没有 则继续往上  如果加载过了 则直接使用父类加载的结果 直到到达顶级 再向下尝试加载&lt;br /&gt;好处  保护程序稳定 防止重复加载 防止java 核心 api被篡改 如自己定义string类&#13;
&lt;a name='mcxZ6'&gt;&lt;/a&gt;&#13;
#### 如何打破双亲委派&#13;
 自定义类加载器 重写加载方法&#13;
&lt;a name='V9hvP'&gt;&lt;/a&gt;&#13;
### JVM&#13;
&lt;a name='hd8LH'&gt;&lt;/a&gt;&#13;
#### 内存区域&#13;
程序计数器  线程私有 记录代码运行位置 控制流程&lt;br /&gt;栈 分为虚拟机栈和本地方法栈 线程私有 方法开始压入栈帧 退出弹出栈帧 &lt;br /&gt;堆 线程共享 存储对象 gc重要位置 分为 新生代和老生代 新生代分为ende区 s0 s1 &lt;br /&gt;方法区/元空间 线程共享 存储 类信息 常量等信息&lt;br /&gt;直接内存&#13;
&lt;a name='IjIsL'&gt;&lt;/a&gt;&#13;
#### GC&#13;
判断是否为垃圾的算法&lt;br /&gt;1.引用计数法 有对象引用时+1 引用被清理时-1 引用为0 则为垃圾 弊端 无法解决循环引用问题&lt;br /&gt;2.可达性分析法 从gc root开始往下找 找不到的对象均为垃圾  何为gcroot? 栈中引用的对象 方法区中静态属性和常量引用的对象 被同步锁持有的对象 &#13;
&#13;
垃圾回收算法:&lt;br /&gt;标记清除法 先标记需要清理的对象 再一次性回收 弊端 会造成大量的空间碎片 &lt;br /&gt;标记复制法  将内存分为两大块 将需要回收的对象复制到空的内存块 再清理 弊端 内存消耗过大&lt;br /&gt;标记整理法   将需要清理的内存标记 再将所有存活对象往一端移动 然后清理端边界的对象 &#13;
&#13;
垃圾回收器:&lt;br /&gt;串行垃圾回收器 原始版本 stw时间长 单线程垃圾回收 适用于小内存&lt;br /&gt;并行垃圾回收器 串行的衍生版本 唯一不同的是垃圾回收时 多线程并行 减少stw时间&lt;br /&gt;cms&lt;br /&gt;g1&#13;
&lt;a name='zmk00'&gt;&lt;/a&gt;&#13;
#### 频繁出现GC的原因&#13;
cpu负载过高&lt;br /&gt;大对象太多&lt;br /&gt;老年代内存不足导致 频繁full gc &#13;
&lt;a name='ljQ8Y'&gt;&lt;/a&gt;&#13;
## spring&#13;
&lt;a name='I39Vj'&gt;&lt;/a&gt;&#13;
### ioc&#13;
控制反转和依赖注入 原理是反射 &#13;
&lt;a name='Eh6nE'&gt;&lt;/a&gt;&#13;
### aop&#13;
切面 原理是反射和动态代理 生成动态代理对象 可对方法执行前和执行后进行拦截做处理&#13;
&lt;a name='dR3WA'&gt;&lt;/a&gt;&#13;
### bean的作用域&#13;
单例 默认 bean容器中所有bean都是唯一的&lt;br /&gt;多例 每次获取都是一个新bean&lt;br /&gt;requset 每个请求都是一个新bean&lt;br /&gt;session 每个session都是一个新bean&#13;
&lt;a name='JQvsP'&gt;&lt;/a&gt;&#13;
### bean的生命周期&#13;
&#13;
1. 实例化&#13;
2. 属性设置&#13;
3. 前置处理&#13;
4. 初始化处理&#13;
5. 后置处理&#13;
6. 使用中&#13;
7. 销毁前置操作&#13;
8. 死亡&#13;
&lt;a name='Humjr'&gt;&lt;/a&gt;&#13;
## springmvc&#13;
&lt;a name='biEUj'&gt;&lt;/a&gt;&#13;
### springmvc执行流程&#13;
请求过来 先到 调度servlet 由调度servlet找到处理器 handmapping 然后适配处理器 然后调用处理器找到对应的控制器 然后由控制器返回视图 渲染视图  &#13;
&lt;a name='OwubK'&gt;&lt;/a&gt;&#13;
## springboot&#13;
&lt;a name='Mh9xT'&gt;&lt;/a&gt;&#13;
## springcloud&#13;
&#13;
1. Nacos 注册中心&#13;
2. Ribbon 负载均衡&#13;
3. OpenFeign 程序通信 http接口调用&#13;
4. Sentinel 降级 限流 服务保护 &#13;
5. Gateway 网关 鉴权&#13;
6. Seata 分布式事务 二阶段提交 AT模式和TCC模式&#13;
&lt;a name='saFqN'&gt;&lt;/a&gt;&#13;
## mybatis&#13;
&lt;a name='LgOxQ'&gt;&lt;/a&gt;&#13;
## redis&#13;
&lt;a name='k21L7'&gt;&lt;/a&gt;&#13;
## mq&#13;
&lt;a name='hidFN'&gt;&lt;/a&gt;&#13;
### 事务消费&#13;
&lt;a name='uKi8v'&gt;&lt;/a&gt;&#13;
### 顺序消费&#13;
&lt;a name='sCjx0'&gt;&lt;/a&gt;&#13;
## mysql&#13;
&lt;a name='joSNR'&gt;&lt;/a&gt;&#13;
### 常见锁&#13;
共享锁 读锁 排他锁 写锁 间隙锁 行锁 表锁等&#13;
&lt;a name='fKJzk'&gt;&lt;/a&gt;&#13;
### 数据引擎&#13;
myisam和innodb的区别&lt;br /&gt;myisam 不支持事务 文件存储分为两个文件 索引文件和数据文件分开&lt;br /&gt;innodb 支持事务 文件存储 一个文件 索引和数据都在一个文件中 mysql默认&#13;
&lt;a name='xF1l9'&gt;&lt;/a&gt;&#13;
### 索引&#13;
 普通索引 唯一索引 innodb中的主键索引(聚簇索引,特殊的唯一索引),联合索引,全文索引&lt;br /&gt; 底层B+Tree 多叉平衡树 叶子节点中有指针相连 节点有序 &lt;br /&gt; 索引覆盖 所需要查询的字段都建立了索引 不需要回表查询&lt;br /&gt; 最左匹配原则 如果联合索引 abc三个字段 那么查询的时候必须要有a这个字段的做为条件 才会走联合索引 因为存储索引的时候是按照从左往右按大小排序的&#13;
&lt;a name='CwBPK'&gt;&lt;/a&gt;&#13;
### 事务特征&#13;
 	A原子性 同时成功同时失败 &lt;br /&gt; 	C 一致性 事务要保持最终一致性  一致性需要 其他三个特征来保证&lt;br /&gt; 	I 隔离性 根据事务隔离级别控制 保证不同事务的隔离性&lt;br /&gt; 	D 持久性 事务最终需要持久化到数据库中  &#13;
&lt;a name='JpxEB'&gt;&lt;/a&gt;&#13;
### 事务隔离级别&#13;
 	读未提交  会产生脏读  级别最低 可以读到未提交的事务&lt;br /&gt; 	读已提交 不可重复读  两次查询可能会产生不一样的结果&lt;br /&gt; 	可重复读 mysql默认 会产生幻读 每次读取结果都一样&lt;br /&gt; 可串行化 级别最高 并发性能低 所有事务串行进行&#13;
&lt;a name='V6Irz'&gt;&lt;/a&gt;&#13;
### mvcc&#13;
在不可重复读和可重复读的事务隔离级别中有效 用来保证 事务的并发性&lt;br /&gt;原理是通过版本链来控制 在每个表中有两个隐藏字段 一个是事务id一个是上个版本的地址快照&lt;br /&gt;不可重复读中 每次查询都会生成新的 readView 所以会产生两次查询不一样&lt;br /&gt;可重复读中 会使用上次的readView 所以每次读取结果都一样 &#13;
&lt;a name='xnPLQ'&gt;&lt;/a&gt;&#13;
### mysql 锁等待超时&#13;
&lt;a name='cSEgX'&gt;&lt;/a&gt;&#13;
### limit 大数据量优化&#13;
&lt;a name='MJmJe'&gt;&lt;/a&gt;&#13;
## liunx&#13;
&#13;
last:20240625。</description><guid isPermaLink="true">https://blog.000828.top//post/Java--mian-shi-zong-jie---chi-xu-geng-xin.html</guid><pubDate>Tue, 25 Jun 2024 09:53:14 +0000</pubDate></item><item><title>Java-线程工具</title><link>https://blog.000828.top//post/Java--xian-cheng-gong-ju.html</link><description>1.多个线程并行执行,主线程阻塞等待所有子线程执行完(CountDownLatch实现)&#13;
源码:&#13;
```java&#13;
import java.util.concurrent.CountDownLatch;&#13;
&#13;
&#13;
public class CountDownLatchUtil {&#13;
&#13;
&#13;
    public static void allOf(Runnable... runnableArray) {&#13;
        if (arrayIsEmpty(runnableArray)) {&#13;
            return;&#13;
        }&#13;
        CountDownLatch countDownLatch = new CountDownLatch(runnableArray.length);&#13;
        for (Runnable runnable : runnableArray) {&#13;
            //  建议使用线程池&#13;
            new Thread(() -&gt; {&#13;
                runnable.run();&#13;
                countDownLatch.countDown();&#13;
            }).start();&#13;
        }&#13;
        try {&#13;
            countDownLatch.await();&#13;
        } catch (InterruptedException e) {&#13;
            e.printStackTrace();&#13;
        }&#13;
    }&#13;
&#13;
    private static &lt;T&gt; boolean arrayIsEmpty(T[] array) {&#13;
        return array == null || array.length == 0;&#13;
    }&#13;
}&#13;
``` &#13;
 使用示例:&#13;
![image](https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/assets/50692323/9c458e5e-6dbc-4e98-b47a-59714052dc6e)&#13;
&#13;
后面发现Java8提供了CompletableFuture也可以实现,但是感觉用起来没有自己写的简单&#13;
2.多线程并行操作集合&#13;
源码:&#13;
```java&#13;
import java.util.ArrayList;&#13;
import java.util.Collection;&#13;
import java.util.List;&#13;
import java.util.function.Consumer;&#13;
&#13;
&#13;
public class AsyncHandleUtil {&#13;
&#13;
    private static final int DEFAULT_PAGE_SIZE = 1000;&#13;
&#13;
    public static &lt;T&gt; void asyncHandle(List&lt;T&gt; list, Consumer&lt;T&gt; action, int pageSize) {&#13;
        if (collectionIsEmpty(list)) {&#13;
            return;&#13;
        }&#13;
        int totalPage = totalPage(list.size(), pageSize);&#13;
        for (int i = 0; i &lt; totalPage; i++) {&#13;
            int pageNum = i + 1;&#13;
            //  建议使用线程池&#13;
            new Thread(() -&gt; {&#13;
                List&lt;T&gt; newDataList = getListPaging(list, pageNum, pageSize);&#13;
                for (T t : newDataList) {&#13;
                    action.accept(t);&#13;
                }&#13;
            }).start();&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    public static &lt;T&gt; void asyncHandle(List&lt;T&gt; list, Consumer&lt;T&gt; action) {&#13;
        asyncHandle(list, action, DEFAULT_PAGE_SIZE);&#13;
    }&#13;
&#13;
&#13;
    private static int totalPage(int totalCount, int pageSize) {&#13;
        if (pageSize == 0) {&#13;
            return 0;&#13;
        } else {&#13;
            return totalCount % pageSize == 0 ? totalCount / pageSize : totalCount / pageSize + 1;&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    private static boolean collectionIsEmpty(Collection&lt;?&gt; collection) {&#13;
        return collection == null || collection.isEmpty();&#13;
    }&#13;
&#13;
&#13;
    private static &lt;T&gt; List&lt;T&gt; getListPaging(List&lt;T&gt; list, int pageNum, int pageSize) {&#13;
        if (collectionIsEmpty(list)) {&#13;
            return new ArrayList&lt;&gt;(0);&#13;
        }&#13;
        int startIndex = (pageNum - 1) * pageSize;&#13;
        int endIndex = pageNum * pageSize;&#13;
        int total = list.size();&#13;
        int pageCount;&#13;
        int num = total % pageSize;&#13;
        if (num == 0) {&#13;
            pageCount = total / pageSize;&#13;
        } else {&#13;
            pageCount = total / pageSize + 1;&#13;
        }&#13;
        if (pageNum == pageCount) {&#13;
            endIndex = total;&#13;
        }&#13;
        return list.subList(startIndex, endIndex);&#13;
    }&#13;
}&#13;
```&#13;
使用示例:&#13;
![image](https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/assets/50692323/728ade16-98fe-4c5a-bcce-de7e6bed5cd9)&#13;
&#13;
跟Java8的并行流操作差不多,但是更灵活。</description><guid isPermaLink="true">https://blog.000828.top//post/Java--xian-cheng-gong-ju.html</guid><pubDate>Tue, 25 Jun 2024 09:43:13 +0000</pubDate></item><item><title>域名记录</title><link>https://blog.000828.top//post/yu-ming-ji-lu.html</link><description>[blog.000828.top](https://blog.000828.top) 站点域名购买商:[https://www.namesilo.com/](https://www.namesilo.com/)&#13;
有个羊毛可以薅 [https://customer.l53.net/](https://customer.l53.net/) &#13;
注册新用户可以免费申请一个一年的域名 购买的时候 填入优惠码 **newuser**  结算等通过就可以 &#13;
暂时没有测试是否支持cloudflare&#13;
`000828 是个特殊的数字 我希望可以一直持有这个域名`。</description><guid isPermaLink="true">https://blog.000828.top//post/yu-ming-ji-lu.html</guid><pubDate>Tue, 25 Jun 2024 09:09:28 +0000</pubDate></item><item><title>One-year anniversary</title><link>https://blog.000828.top//post/One-year%20anniversary.html</link><description>&gt; [!NOTE]&#13;
&gt;**Happy one-year anniversary**&#13;
&#13;
![4729ebda3d25333694721](https://img.000828.top/file/4729ebda3d25333694721.jpg)&#13;
![61c55d5ff4ff6c09adfb4](https://img.000828.top/file/61c55d5ff4ff6c09adfb4.jpg)&#13;
![4ec2c5eb4983f0051589c](https://img.000828.top/file/4ec2c5eb4983f0051589c.jpg)&#13;
![2a09dd675ac91a0a06bf6](https://img.000828.top/file/2a09dd675ac91a0a06bf6.jpg)&#13;
`时间真快,一转眼在一起一年了,这一年的时间了 我们相互了解彼此 有开心有眼泪 相互磨合 会吵架 会冷战 也会恩爱甜蜜 嘻嘻 这些都不重要 重要的是 我还是很爱你 热爱可抵岁月漫长 😀`&#13;
&lt;!-- ##{'timestamp':1704245082}## --&gt;。</description><guid isPermaLink="true">https://blog.000828.top//post/One-year%20anniversary.html</guid><pubDate>Wed, 03 Jan 2024 01:24:42 +0000</pubDate></item><item><title>The most important day</title><link>https://blog.000828.top//post/The%20most%20important%20day.html</link><description>&gt; [!NOTE]&#13;
&gt;**We're together**&#13;
`Gmeek-html&lt;img src='https://img.000828.top/file/8e00303191742684579cd.jpg' loading='lazy'&gt;`&#13;
`过程很挫折,结果很完美,这一定是人生中最幸福的一天,虽然当时还有点患得患失,虽然刚在一起就异地,但是 还是很开心 无法用言语表达的开心 😀`&#13;
&lt;!-- ##{'timestamp':1672675200}## --&gt;。</description><guid isPermaLink="true">https://blog.000828.top//post/The%20most%20important%20day.html</guid><pubDate>Mon, 02 Jan 2023 16:00:00 +0000</pubDate></item><item><title>关于 | about me</title><link>https://blog.000828.top//about.html</link><description>**自我介绍 | `Self-introduction`**&#13;
 &#13;
&gt; 我是一名程序员，热爱编程和技术创新。</description><guid isPermaLink="true">https://blog.000828.top//about.html</guid><pubDate>Tue, 25 Jun 2024 06:19:03 +0000</pubDate></item></channel></rss>