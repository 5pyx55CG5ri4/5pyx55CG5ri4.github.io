<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>5pyx55CG5ri4</title><link>https://blog.000828.top/</link><description>永远相信美好的事情即将发生</description><copyright>5pyx55CG5ri4</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/50692323?v=4&amp;size=64</url><title>avatar</title><link>https://blog.000828.top/</link></image><lastBuildDate>Wed, 26 Jun 2024 01:15:24 +0000</lastBuildDate><managingEditor>5pyx55CG5ri4</managingEditor><ttl>60</ttl><webMaster>5pyx55CG5ri4</webMaster><item><title>Java-面试总结-持续更新</title><link>https://blog.000828.top//post/Java--mian-shi-zong-jie---chi-xu-geng-xin.html</link><description>&lt;a name='bVG8o'&gt;&lt;/a&gt;&#13;
## Java基础&#13;
&lt;a name='GyAoN'&gt;&lt;/a&gt;&#13;
### 集合&#13;
&lt;a name='Huyq9'&gt;&lt;/a&gt;&#13;
#### List&#13;
arraylist new初始容量为0 空数组 add第一个元素 扩容到10 后续每次扩容1.5倍左右 底层是数组复制来实现&#13;
&lt;a name='D81x3'&gt;&lt;/a&gt;&#13;
#### map&#13;
hashmap 1.7 数组+链表 1.8数组+链表+红黑树 &lt;br /&gt;初始容量16 负载因子0.75(意味着容量到了百分之75的时候扩容) 当出现hash冲突 会使用拉链法解决冲突 如果同一个hash结果 key不同 进入链表 如果链表长度达到8 则转化为红黑树 转换前会判断数组长度是否大于64 如果小于64则会先对数组进行扩容 hashmap每次扩容是2倍 2的次幂 &#13;
&lt;a name='zVXi1'&gt;&lt;/a&gt;&#13;
### io&#13;
&lt;a name='Lw7sM'&gt;&lt;/a&gt;&#13;
### 多线程&#13;
&lt;a name='bED23'&gt;&lt;/a&gt;&#13;
#### 开启多线程的几种方式&#13;
 继承线程类或者实现接口&#13;
&lt;a name='xxVR7'&gt;&lt;/a&gt;&#13;
#### 线程的生命周期&#13;
&#13;
1. 准备状态 如new thred 未调用start方法时&#13;
2. 就绪状态 调用了start方法 等待cpu资源&#13;
3. 运行状态&#13;
4. 阻塞状态 调用了sleep方法或者 wait方法&#13;
5. 线程结束&#13;
&lt;a name='GEfNg'&gt;&lt;/a&gt;&#13;
#### 线程池参数&#13;
&#13;
1. 核心线程数&#13;
2. 最大线程数&#13;
3. 工作阻塞队列&#13;
4. 空闲线程存活时间&#13;
5. 存活时间单位&#13;
6. 拒绝策略&#13;
7. 线程工厂(不重要)&#13;
&lt;a name='WpeCu'&gt;&lt;/a&gt;&#13;
#### 线程池执行流程&#13;
一个任务进来  先开核心线程数是否超过设置的数量 如果没有 由核心线程执行任务如果核心线程数超过了设置的数量 则加入工作队列等待 如果 工作队列满了 并且没超过最大线程数 则开启临时新线程执行 临时线程存活时间由参数控制 回收 如果工作队列满了并且超过了最大线程数 则走拒绝策略&#13;
&lt;a name='LADTg'&gt;&lt;/a&gt;&#13;
#### ThredLocal&#13;
在每个线程中都有独立的一个thredlocalmap key为thredlocal value为存储的值 其中 key为弱引用 需要手动清理 否则可能会导致内存泄漏问题&#13;
&lt;a name='iu8OP'&gt;&lt;/a&gt;&#13;
#### sleep,wait&#13;
sleep是thred类的方法 作用是 休眠当前线程 无需唤醒&lt;br /&gt;wait是object类方法 作用是是当前线程阻塞等待 在无参的方法中 需要等待别人唤醒&#13;
&lt;a name='IViPI'&gt;&lt;/a&gt;&#13;
### 锁机制&#13;
&lt;a name='PRy6Z'&gt;&lt;/a&gt;&#13;
#### volatile,sychronized和reentrantLock&#13;
volatile 关键字修饰变量 可以保证变量对每个线程的可见性 不加关键字 线程中读取的变量为从主内存复制的副本 加了关键字修饰 则直接读取主内存中的值&lt;br /&gt;sychronized jvm提供的锁 为关键字 锁住的是对象头 分为 偏向锁 轻量级锁 自旋锁 重量级锁 是可重入锁 无法实现公平锁 无需手动释放锁&lt;br /&gt;reentrantLock 是类 java提供的锁api 底层是aqs 锁的是int类型的state值 可重入锁 可实现公平锁和非公平锁 无参构造的是非公平锁 需要手动释放锁&#13;
&lt;a name='NxzBu'&gt;&lt;/a&gt;&#13;
#### AQS&#13;
aqs底层是一个双向队列和一个state信号量 java juc基本都依赖aqs框架 主要维护 信号量放行的逻辑&#13;
&lt;a name='HynM0'&gt;&lt;/a&gt;&#13;
#### CAS&#13;
比较并替换 可实现 乐观锁 &#13;
&lt;a name='fjAPn'&gt;&lt;/a&gt;&#13;
### 类加载机制&#13;
&lt;a name='upWzo'&gt;&lt;/a&gt;&#13;
#### 类加载过程&#13;
&#13;
1. 加载:加载class文件 &#13;
2. 连接:1.验证 验证class文件合法性 2.准备 为变量设置内存并赋初始值 3.解析&#13;
3. 初始化&#13;
&lt;a name='f2BXz'&gt;&lt;/a&gt;&#13;
#### 双亲委派机制&#13;
加载类的时候 会先向父类加载器找有没有加载过这个类 如果没有 则继续往上  如果加载过了 则直接使用父类加载的结果 直到到达顶级 再向下尝试加载&lt;br /&gt;好处  保护程序稳定 防止重复加载 防止java 核心 api被篡改 如自己定义string类&#13;
&lt;a name='mcxZ6'&gt;&lt;/a&gt;&#13;
#### 如何打破双亲委派&#13;
 自定义类加载器 重写加载方法&#13;
&lt;a name='V9hvP'&gt;&lt;/a&gt;&#13;
### JVM&#13;
&lt;a name='hd8LH'&gt;&lt;/a&gt;&#13;
#### 内存区域&#13;
程序计数器  线程私有 记录代码运行位置 控制流程&lt;br /&gt;栈 分为虚拟机栈和本地方法栈 线程私有 方法开始压入栈帧 退出弹出栈帧 &lt;br /&gt;堆 线程共享 存储对象 gc重要位置 分为 新生代和老生代 新生代分为ende区 s0 s1 &lt;br /&gt;方法区/元空间 线程共享 存储 类信息 常量等信息&lt;br /&gt;直接内存&#13;
&lt;a name='IjIsL'&gt;&lt;/a&gt;&#13;
#### GC&#13;
判断是否为垃圾的算法&lt;br /&gt;1.引用计数法 有对象引用时+1 引用被清理时-1 引用为0 则为垃圾 弊端 无法解决循环引用问题&lt;br /&gt;2.可达性分析法 从gc root开始往下找 找不到的对象均为垃圾  何为gcroot? 栈中引用的对象 方法区中静态属性和常量引用的对象 被同步锁持有的对象 &#13;
&#13;
垃圾回收算法:&lt;br /&gt;标记清除法 先标记需要清理的对象 再一次性回收 弊端 会造成大量的空间碎片 &lt;br /&gt;标记复制法  将内存分为两大块 将需要回收的对象复制到空的内存块 再清理 弊端 内存消耗过大&lt;br /&gt;标记整理法   将需要清理的内存标记 再将所有存活对象往一端移动 然后清理端边界的对象 &#13;
&#13;
垃圾回收器:&lt;br /&gt;串行垃圾回收器 原始版本 stw时间长 单线程垃圾回收 适用于小内存&lt;br /&gt;并行垃圾回收器 串行的衍生版本 唯一不同的是垃圾回收时 多线程并行 减少stw时间&lt;br /&gt;cms&lt;br /&gt;g1&#13;
&lt;a name='zmk00'&gt;&lt;/a&gt;&#13;
#### 频繁出现GC的原因&#13;
cpu负载过高&lt;br /&gt;大对象太多&lt;br /&gt;老年代内存不足导致 频繁full gc &#13;
&lt;a name='ljQ8Y'&gt;&lt;/a&gt;&#13;
## spring&#13;
&lt;a name='I39Vj'&gt;&lt;/a&gt;&#13;
### ioc&#13;
控制反转和依赖注入 原理是反射 &#13;
&lt;a name='Eh6nE'&gt;&lt;/a&gt;&#13;
### aop&#13;
切面 原理是反射和动态代理 生成动态代理对象 可对方法执行前和执行后进行拦截做处理&#13;
&lt;a name='dR3WA'&gt;&lt;/a&gt;&#13;
### bean的作用域&#13;
单例 默认 bean容器中所有bean都是唯一的&lt;br /&gt;多例 每次获取都是一个新bean&lt;br /&gt;requset 每个请求都是一个新bean&lt;br /&gt;session 每个session都是一个新bean&#13;
&lt;a name='JQvsP'&gt;&lt;/a&gt;&#13;
### bean的生命周期&#13;
&#13;
1. 实例化&#13;
2. 属性设置&#13;
3. 前置处理&#13;
4. 初始化处理&#13;
5. 后置处理&#13;
6. 使用中&#13;
7. 销毁前置操作&#13;
8. 死亡&#13;
&lt;a name='Humjr'&gt;&lt;/a&gt;&#13;
## springmvc&#13;
&lt;a name='biEUj'&gt;&lt;/a&gt;&#13;
### springmvc执行流程&#13;
请求过来 先到 调度servlet 由调度servlet找到处理器 handmapping 然后适配处理器 然后调用处理器找到对应的控制器 然后由控制器返回视图 渲染视图  &#13;
&lt;a name='OwubK'&gt;&lt;/a&gt;&#13;
## springboot&#13;
&lt;a name='Mh9xT'&gt;&lt;/a&gt;&#13;
## springcloud&#13;
&#13;
1. Nacos 注册中心&#13;
2. Ribbon 负载均衡&#13;
3. OpenFeign 程序通信 http接口调用&#13;
4. Sentinel 降级 限流 服务保护 &#13;
5. Gateway 网关 鉴权&#13;
6. Seata 分布式事务 二阶段提交 AT模式和TCC模式&#13;
&lt;a name='saFqN'&gt;&lt;/a&gt;&#13;
## mybatis&#13;
&lt;a name='LgOxQ'&gt;&lt;/a&gt;&#13;
## redis&#13;
&lt;a name='k21L7'&gt;&lt;/a&gt;&#13;
## mq&#13;
&lt;a name='hidFN'&gt;&lt;/a&gt;&#13;
### 事务消费&#13;
&lt;a name='uKi8v'&gt;&lt;/a&gt;&#13;
### 顺序消费&#13;
&lt;a name='sCjx0'&gt;&lt;/a&gt;&#13;
## mysql&#13;
&lt;a name='joSNR'&gt;&lt;/a&gt;&#13;
### 常见锁&#13;
共享锁 读锁 排他锁 写锁 间隙锁 行锁 表锁等&#13;
&lt;a name='fKJzk'&gt;&lt;/a&gt;&#13;
### 数据引擎&#13;
myisam和innodb的区别&lt;br /&gt;myisam 不支持事务 文件存储分为两个文件 索引文件和数据文件分开&lt;br /&gt;innodb 支持事务 文件存储 一个文件 索引和数据都在一个文件中 mysql默认&#13;
&lt;a name='xF1l9'&gt;&lt;/a&gt;&#13;
### 索引&#13;
 普通索引 唯一索引 innodb中的主键索引(聚簇索引,特殊的唯一索引),联合索引,全文索引&lt;br /&gt; 底层B+Tree 多叉平衡树 叶子节点中有指针相连 节点有序 &lt;br /&gt; 索引覆盖 所需要查询的字段都建立了索引 不需要回表查询&lt;br /&gt; 最左匹配原则 如果联合索引 abc三个字段 那么查询的时候必须要有a这个字段的做为条件 才会走联合索引 因为存储索引的时候是按照从左往右按大小排序的&#13;
&lt;a name='CwBPK'&gt;&lt;/a&gt;&#13;
### 事务特征&#13;
 	A原子性 同时成功同时失败 &lt;br /&gt; 	C 一致性 事务要保持最终一致性  一致性需要 其他三个特征来保证&lt;br /&gt; 	I 隔离性 根据事务隔离级别控制 保证不同事务的隔离性&lt;br /&gt; 	D 持久性 事务最终需要持久化到数据库中  &#13;
&lt;a name='JpxEB'&gt;&lt;/a&gt;&#13;
### 事务隔离级别&#13;
 	读未提交  会产生脏读  级别最低 可以读到未提交的事务&lt;br /&gt; 	读已提交 不可重复读  两次查询可能会产生不一样的结果&lt;br /&gt; 	可重复读 mysql默认 会产生幻读 每次读取结果都一样&lt;br /&gt; 可串行化 级别最高 并发性能低 所有事务串行进行&#13;
&lt;a name='V6Irz'&gt;&lt;/a&gt;&#13;
### mvcc&#13;
在不可重复读和可重复读的事务隔离级别中有效 用来保证 事务的并发性&lt;br /&gt;原理是通过版本链来控制 在每个表中有两个隐藏字段 一个是事务id一个是上个版本的地址快照&lt;br /&gt;不可重复读中 每次查询都会生成新的 readView 所以会产生两次查询不一样&lt;br /&gt;可重复读中 会使用上次的readView 所以每次读取结果都一样 &#13;
&lt;a name='xnPLQ'&gt;&lt;/a&gt;&#13;
### mysql 锁等待超时&#13;
&lt;a name='cSEgX'&gt;&lt;/a&gt;&#13;
### limit 大数据量优化&#13;
&lt;a name='MJmJe'&gt;&lt;/a&gt;&#13;
## liunx&#13;
&#13;
last:20240625。</description><guid isPermaLink="true">https://blog.000828.top//post/Java--mian-shi-zong-jie---chi-xu-geng-xin.html</guid><pubDate>Tue, 25 Jun 2024 09:53:14 +0000</pubDate></item><item><title>Java-线程工具</title><link>https://blog.000828.top//post/Java--xian-cheng-gong-ju.html</link><description>1.多个线程并行执行,主线程阻塞等待所有子线程执行完(CountDownLatch实现)&#13;
源码:&#13;
```java&#13;
import java.util.concurrent.CountDownLatch;&#13;
&#13;
&#13;
public class CountDownLatchUtil {&#13;
&#13;
&#13;
    public static void allOf(Runnable... runnableArray) {&#13;
        if (arrayIsEmpty(runnableArray)) {&#13;
            return;&#13;
        }&#13;
        CountDownLatch countDownLatch = new CountDownLatch(runnableArray.length);&#13;
        for (Runnable runnable : runnableArray) {&#13;
            //  建议使用线程池&#13;
            new Thread(() -&gt; {&#13;
                runnable.run();&#13;
                countDownLatch.countDown();&#13;
            }).start();&#13;
        }&#13;
        try {&#13;
            countDownLatch.await();&#13;
        } catch (InterruptedException e) {&#13;
            e.printStackTrace();&#13;
        }&#13;
    }&#13;
&#13;
    private static &lt;T&gt; boolean arrayIsEmpty(T[] array) {&#13;
        return array == null || array.length == 0;&#13;
    }&#13;
}&#13;
``` &#13;
 使用示例:&#13;
![image](https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/assets/50692323/9c458e5e-6dbc-4e98-b47a-59714052dc6e)&#13;
&#13;
后面发现Java8提供了CompletableFuture也可以实现,但是感觉用起来没有自己写的简单&#13;
2.多线程并行操作集合&#13;
源码:&#13;
```java&#13;
import java.util.ArrayList;&#13;
import java.util.Collection;&#13;
import java.util.List;&#13;
import java.util.function.Consumer;&#13;
&#13;
&#13;
public class AsyncHandleUtil {&#13;
&#13;
    private static final int DEFAULT_PAGE_SIZE = 1000;&#13;
&#13;
    public static &lt;T&gt; void asyncHandle(List&lt;T&gt; list, Consumer&lt;T&gt; action, int pageSize) {&#13;
        if (collectionIsEmpty(list)) {&#13;
            return;&#13;
        }&#13;
        int totalPage = totalPage(list.size(), pageSize);&#13;
        for (int i = 0; i &lt; totalPage; i++) {&#13;
            int pageNum = i + 1;&#13;
            //  建议使用线程池&#13;
            new Thread(() -&gt; {&#13;
                List&lt;T&gt; newDataList = getListPaging(list, pageNum, pageSize);&#13;
                for (T t : newDataList) {&#13;
                    action.accept(t);&#13;
                }&#13;
            }).start();&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    public static &lt;T&gt; void asyncHandle(List&lt;T&gt; list, Consumer&lt;T&gt; action) {&#13;
        asyncHandle(list, action, DEFAULT_PAGE_SIZE);&#13;
    }&#13;
&#13;
&#13;
    private static int totalPage(int totalCount, int pageSize) {&#13;
        if (pageSize == 0) {&#13;
            return 0;&#13;
        } else {&#13;
            return totalCount % pageSize == 0 ? totalCount / pageSize : totalCount / pageSize + 1;&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    private static boolean collectionIsEmpty(Collection&lt;?&gt; collection) {&#13;
        return collection == null || collection.isEmpty();&#13;
    }&#13;
&#13;
&#13;
    private static &lt;T&gt; List&lt;T&gt; getListPaging(List&lt;T&gt; list, int pageNum, int pageSize) {&#13;
        if (collectionIsEmpty(list)) {&#13;
            return new ArrayList&lt;&gt;(0);&#13;
        }&#13;
        int startIndex = (pageNum - 1) * pageSize;&#13;
        int endIndex = pageNum * pageSize;&#13;
        int total = list.size();&#13;
        int pageCount;&#13;
        int num = total % pageSize;&#13;
        if (num == 0) {&#13;
            pageCount = total / pageSize;&#13;
        } else {&#13;
            pageCount = total / pageSize + 1;&#13;
        }&#13;
        if (pageNum == pageCount) {&#13;
            endIndex = total;&#13;
        }&#13;
        return list.subList(startIndex, endIndex);&#13;
    }&#13;
}&#13;
```&#13;
使用示例:&#13;
![image](https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/assets/50692323/728ade16-98fe-4c5a-bcce-de7e6bed5cd9)&#13;
&#13;
跟Java8的并行流操作差不多,但是更灵活。</description><guid isPermaLink="true">https://blog.000828.top//post/Java--xian-cheng-gong-ju.html</guid><pubDate>Tue, 25 Jun 2024 09:43:13 +0000</pubDate></item><item><title>The most important day</title><link>https://blog.000828.top//post/The%20most%20important%20day.html</link><description>&gt; [!NOTE]&#13;
&gt;**We're together**&#13;
`Gmeek-html&lt;img src='https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/assets/50692323/1d7cf143-b782-412f-99d1-f9bc3508db25' loading='lazy'&gt;`&#13;
to 2023.01.03&#13;
。</description><guid isPermaLink="true">https://blog.000828.top//post/The%20most%20important%20day.html</guid><pubDate>Tue, 25 Jun 2024 09:16:28 +0000</pubDate></item><item><title>域名记录</title><link>https://blog.000828.top//post/yu-ming-ji-lu.html</link><description>[blog.000828.top](https://blog.000828.top) 站点域名购买商:[https://www.namesilo.com/](https://www.namesilo.com/)&#13;
有个羊毛可以薅 [https://customer.l53.net/](https://customer.l53.net/) &#13;
注册新用户可以免费申请一个一年的域名 购买的时候 填入优惠码 **newuser**  结算等通过就可以 &#13;
暂时没有测试是否支持cloudflare&#13;
`000828 是个特殊的数字 我希望可以一直持有这个域名`。</description><guid isPermaLink="true">https://blog.000828.top//post/yu-ming-ji-lu.html</guid><pubDate>Tue, 25 Jun 2024 09:09:28 +0000</pubDate></item><item><title>关于</title><link>https://blog.000828.top//about.html</link><description>我是一名程序员，热爱编程和技术创新。</description><guid isPermaLink="true">https://blog.000828.top//about.html</guid><pubDate>Tue, 25 Jun 2024 06:19:03 +0000</pubDate></item></channel></rss>