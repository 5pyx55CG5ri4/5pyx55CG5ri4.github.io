<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>5pyx55CG5ri4</title><link>https://blog.000828.top/</link><description>永远相信美好的事情即将发生</description><copyright>5pyx55CG5ri4</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/50692323?v=4&amp;size=64</url><title>avatar</title><link>https://blog.000828.top/</link></image><lastBuildDate>Tue, 25 Jun 2024 09:43:35 +0000</lastBuildDate><managingEditor>5pyx55CG5ri4</managingEditor><ttl>60</ttl><webMaster>5pyx55CG5ri4</webMaster><item><title>Java-线程工具</title><link>https://blog.000828.top//post/Java--xian-cheng-gong-ju.html</link><description>1.多个线程并行执行,主线程阻塞等待所有子线程执行完(CountDownLatch实现)&#13;
源码:&#13;
```java&#13;
import java.util.concurrent.CountDownLatch;&#13;
&#13;
&#13;
public class CountDownLatchUtil {&#13;
&#13;
&#13;
    public static void allOf(Runnable... runnableArray) {&#13;
        if (arrayIsEmpty(runnableArray)) {&#13;
            return;&#13;
        }&#13;
        CountDownLatch countDownLatch = new CountDownLatch(runnableArray.length);&#13;
        for (Runnable runnable : runnableArray) {&#13;
            //  建议使用线程池&#13;
            new Thread(() -&gt; {&#13;
                runnable.run();&#13;
                countDownLatch.countDown();&#13;
            }).start();&#13;
        }&#13;
        try {&#13;
            countDownLatch.await();&#13;
        } catch (InterruptedException e) {&#13;
            e.printStackTrace();&#13;
        }&#13;
    }&#13;
&#13;
    private static &lt;T&gt; boolean arrayIsEmpty(T[] array) {&#13;
        return array == null || array.length == 0;&#13;
    }&#13;
}&#13;
``` &#13;
 使用示例:&#13;
![image](https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/assets/50692323/9c458e5e-6dbc-4e98-b47a-59714052dc6e)&#13;
&#13;
后面发现Java8提供了CompletableFuture也可以实现,但是感觉用起来没有自己写的简单&#13;
2.多线程并行操作集合&#13;
源码:&#13;
```java&#13;
import java.util.ArrayList;&#13;
import java.util.Collection;&#13;
import java.util.List;&#13;
import java.util.function.Consumer;&#13;
&#13;
&#13;
public class AsyncHandleUtil {&#13;
&#13;
    private static final int DEFAULT_PAGE_SIZE = 1000;&#13;
&#13;
    public static &lt;T&gt; void asyncHandle(List&lt;T&gt; list, Consumer&lt;T&gt; action, int pageSize) {&#13;
        if (collectionIsEmpty(list)) {&#13;
            return;&#13;
        }&#13;
        int totalPage = totalPage(list.size(), pageSize);&#13;
        for (int i = 0; i &lt; totalPage; i++) {&#13;
            int pageNum = i + 1;&#13;
            //  建议使用线程池&#13;
            new Thread(() -&gt; {&#13;
                List&lt;T&gt; newDataList = getListPaging(list, pageNum, pageSize);&#13;
                for (T t : newDataList) {&#13;
                    action.accept(t);&#13;
                }&#13;
            }).start();&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    public static &lt;T&gt; void asyncHandle(List&lt;T&gt; list, Consumer&lt;T&gt; action) {&#13;
        asyncHandle(list, action, DEFAULT_PAGE_SIZE);&#13;
    }&#13;
&#13;
&#13;
    private static int totalPage(int totalCount, int pageSize) {&#13;
        if (pageSize == 0) {&#13;
            return 0;&#13;
        } else {&#13;
            return totalCount % pageSize == 0 ? totalCount / pageSize : totalCount / pageSize + 1;&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    private static boolean collectionIsEmpty(Collection&lt;?&gt; collection) {&#13;
        return collection == null || collection.isEmpty();&#13;
    }&#13;
&#13;
&#13;
    private static &lt;T&gt; List&lt;T&gt; getListPaging(List&lt;T&gt; list, int pageNum, int pageSize) {&#13;
        if (collectionIsEmpty(list)) {&#13;
            return new ArrayList&lt;&gt;(0);&#13;
        }&#13;
        int startIndex = (pageNum - 1) * pageSize;&#13;
        int endIndex = pageNum * pageSize;&#13;
        int total = list.size();&#13;
        int pageCount;&#13;
        int num = total % pageSize;&#13;
        if (num == 0) {&#13;
            pageCount = total / pageSize;&#13;
        } else {&#13;
            pageCount = total / pageSize + 1;&#13;
        }&#13;
        if (pageNum == pageCount) {&#13;
            endIndex = total;&#13;
        }&#13;
        return list.subList(startIndex, endIndex);&#13;
    }&#13;
}&#13;
```&#13;
使用示例:&#13;
![image](https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/assets/50692323/728ade16-98fe-4c5a-bcce-de7e6bed5cd9)&#13;
&#13;
跟Java8的并行流操作差不多,但是更灵活。</description><guid isPermaLink="true">https://blog.000828.top//post/Java--xian-cheng-gong-ju.html</guid><pubDate>Tue, 25 Jun 2024 09:43:13 +0000</pubDate></item><item><title>The most important day</title><link>https://blog.000828.top//post/The%20most%20important%20day.html</link><description>&gt; [!NOTE]&#13;
&gt;**We're together**&#13;
![微信图片_20240625171430](https://github.com/5pyx55CG5ri4/5pyx55CG5ri4.github.io/assets/50692323/1d7cf143-b782-412f-99d1-f9bc3508db25)&#13;
to 2023.01.03&#13;
。</description><guid isPermaLink="true">https://blog.000828.top//post/The%20most%20important%20day.html</guid><pubDate>Tue, 25 Jun 2024 09:16:28 +0000</pubDate></item><item><title>域名记录</title><link>https://blog.000828.top//post/yu-ming-ji-lu.html</link><description>[blog.000828.top](https://blog.000828.top) 站点域名购买商:[https://www.namesilo.com/](https://www.namesilo.com/)。</description><guid isPermaLink="true">https://blog.000828.top//post/yu-ming-ji-lu.html</guid><pubDate>Tue, 25 Jun 2024 09:09:28 +0000</pubDate></item><item><title>关于</title><link>https://blog.000828.top//about.html</link><description>我是一名程序员，热爱编程和技术创新。</description><guid isPermaLink="true">https://blog.000828.top//about.html</guid><pubDate>Tue, 25 Jun 2024 06:19:03 +0000</pubDate></item></channel></rss>